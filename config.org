#+TITLE: Doom Emacs Configuration
#+AUTHOR: Crocodile
#+PROPERTY: header-args :tangle yes :cache yes :results silent :padline no

* Table of Contents :TOC:

- [[#introduction][Introduction]]
- [[#basic-settings][Basic Settings]]
  - [[#directories][Directories]]
  - [[#emacs-server][Emacs Server]]
  - [[#auto-revert-mode][Auto-revert Mode]]
  - [[#user-information][User Information]]
  - [[#line-numbers][Line Numbers]]
  - [[#browser-configuration][Browser Configuration]]
  - [[#performance-tuning][Performance Tuning]]
- [[#visual-configuration][Visual Configuration]]
  - [[#fonts][Fonts]]
  - [[#theme-pywal-integration][Theme: Pywal Integration]]
  - [[#transparency-toggle-and-pywal-auto-reload][Transparency Toggle and Pywal Auto-Reload]]
  - [[#theme-conversion-tools][Theme Conversion Tools]]
- [[#org-roam-configuration][Org-Roam Configuration]]
  - [[#org-roam-ui][Org-Roam UI]]
  - [[#capture-templates][Capture Templates]]
  - [[#org-roam-dailies][Org-Roam Dailies]]
  - [[#helper-functions][Helper Functions]]
  - [[#keybindings][Keybindings]]
  - [[#buffer-navigation][Buffer Navigation]]
- [[#lecture-processing][Lecture Processing]]
- [[#file-navigation][File Navigation]]
  - [[#performance-fast-search-tools][Performance: Fast Search Tools]]
  - [[#yazi-integration-eeeel][Yazi Integration (eee.el)]]
  - [[#dired-configuration][Dired Configuration]]
- [[#rust-configuration][Rust Configuration]]
- [[#ai-integration-copilot][AI Integration: Copilot]]
- [[#ai-integration-gptel][AI Integration: GPTel]]
  - [[#gptel-agent][GPTel Agent]]
- [[#discord-presence][Discord Presence]]
- [[#org-todo][Org-Todo]]
- [[#org-agenda][Org Agenda]]
- [[#google-calendar-integration][Google Calendar Integration]]
  - [[#setup-instructions][Setup Instructions]]
  - [[#configuration][Configuration]]
  - [[#calfw-theme-integration][Calfw Theme Integration]]
  - [[#usage][Usage]]
- [[#org-pomodoro-configuration][Org-Pomodoro Configuration]]
- [[#org-formatting][Org Formatting]]
- [[#org-inline-images][Org Inline Images]]
- [[#zen-mode-customization][Zen Mode Customization]]
- [[#dashboard-customization][Dashboard Customization]]
- [[#vterm-configuration][Vterm Configuration]]
- [[#circe-irc-configuration][Circe IRC Configuration]]

* Introduction

This is my Doom Emacs configuration, written in a literate style using org-mode.
The configuration is focused on academic work with org-roam for knowledge management
and GPTel for AI assistance via GitHub Copilot.

* Basic Settings

** Directories

Set the org-roam directory to my brain2 vault. This must be set before org-roam loads.
#+begin_src emacs-lisp
(setq org-roam-directory "~/Documents/brain2")
#+end_src
Set the general org-directory for agenda and other org features.
#+begin_src emacs-lisp
(setq org-directory "~/Documents/brain2/")
#+end_src

** Emacs Server

Start the emacs server to allow emacsclient connections (required for pywal hooks).
When running in daemon mode, server is already started automatically.
#+begin_src emacs-lisp
;; Only start server if NOT already in daemon mode
(unless (daemonp)
  (require 'server)
  (unless (server-running-p)
    (server-start)))
#+end_src

** EPG and GPG Configuration

Configure Emacs Privacy Guard (EPG) for proper GPG integration with plstore and org-gcal.
#+begin_src emacs-lisp
;; Use GPG agent for password prompts
(setq epg-gpg-program "gpg")
(setq epg-pinentry-mode 'loopback)

;; Cache GPG passphrase in Emacs to avoid repeated prompts
(setq epg-passphrase-alist nil)
(defun my/cache-gpg-passphrase (context handback)
  "Cache GPG passphrase for this session."
  (let ((passphrase (read-passwd "GPG Passphrase: ")))
    (setf (alist-get context epg-passphrase-alist) passphrase)
    passphrase))
(setq epg-ask-passphrase-function #'my/cache-gpg-passphrase)

;; Auto-save plstore without prompting (for oauth tokens)
(setq plstore-cache-passphrase-for-symmetric-encryption t)

;; Ensure GPG can find the agent
(unless (getenv "GPG_AGENT_INFO")
  (let ((agent-sock (format "~/.gnupg/S.gpg-agent")))
    (when (file-exists-p (expand-file-name agent-sock))
      (setenv "GPG_AGENT_INFO" (format "%s:0:1" (expand-file-name agent-sock))))))
#+end_src

** Auto-revert Mode

Enable global auto-revert mode to automatically reload files when they change externally.
This is especially useful when working with external tools like OpenCode.
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(setq auto-revert-interval 20)   ; Check every 20 seconds (less aggressive)
(setq auto-revert-verbose nil)   ; Don't spam messages
#+end_src

** User Information

Configure user information for GPG, email clients, and file templates.
#+begin_src emacs-lisp
;; (setq user-full-name "John Doe"
;;       user-mail-address "john@doe.com")
#+end_src

** Line Numbers

Display line numbers in programming and text modes.
#+begin_src emacs-lisp
(setq display-line-numbers-type t)
#+end_src

** Browser Configuration

Set Helium as the system default browser (handled by xdg-mime).
Emacs will use the system default automatically.
#+begin_src emacs-lisp
;; Use system default browser (set via xdg-mime)
(setq browse-url-browser-function 'browse-url-default-browser)
#+end_src

** Performance Tuning

Optimize Emacs for better responsiveness and lower resource usage.
#+begin_src emacs-lisp
;; Increase garbage collection threshold for less frequent GC pauses
(setq gc-cons-threshold 100000000)  ; 100 MB (default is 800KB)
;; Increase amount of data Emacs reads from processes (better for LSP)
(setq read-process-output-max (* 1024 1024))  ; 1MB (default is 4KB)
;; Don't check VC info during auto-revert (much faster)
(setq auto-revert-check-vc-info nil)
#+end_src

* Visual Configuration

** Fonts

Doom exposes five font variables for customization:
- =doom-font= -- the primary font to use
- =doom-variable-pitch-font= -- a non-monospace font (where applicable)
- =doom-big-font= -- used for =doom-big-font-mode=
- =doom-symbol-font= -- for symbols
- =doom-serif-font= -- for the =fixed-pitch-serif= face
Fonts are left at Doom defaults. Zen mode configures its own font sizing.

** Theme: Pywal Integration

I use =ewal= to integrate pywal colors with Doom themes, allowing my Emacs theme
to automatically match my wallpaper color scheme.
#+begin_src emacs-lisp
;; Set doom-theme early to force ewal-doom-one to load during init
;; This prevents the flash of default theme on cold start
(setq doom-theme 'ewal-doom-one)
(use-package! ewal
  :init (setq ewal-use-built-in-always-p nil
              ewal-use-built-in-on-failure-p t
              ewal-built-in-palette "doom-one"))
(use-package! ewal-doom-themes
  :after ewal
  :config (progn
            ;; Load our ewal fix - prefer compiled version for speed
            (let ((compiled-file (expand-file-name "~/.config/doom/ewal-fix.elc"))
                  (source-file (expand-file-name "~/.config/doom/ewal-fix.el")))
              (if (and (file-exists-p compiled-file)
                       (file-newer-than-file-p compiled-file source-file))
                  (load compiled-file)
                (load source-file)))
            (load-theme 'ewal-doom-one t)
            (enable-theme 'ewal-doom-one)))
#+end_src
Helper functions for smart theme loading - detects doom presets vs wallpaper themes:
#+begin_src emacs-lisp
(defvar my/preset-theme-cache nil
  "Cache for preset theme detection to avoid repeated JSON parsing.")
(defun my/detect-preset-theme (&optional force-refresh)
  "Detect which preset theme is currently active from pywal cache.
Returns (TYPE . NAME) where TYPE is 'doom or 'other, and NAME is the theme name.
For doom themes: NAME is like 'gruvbox-light' (without 'doom-' prefix).
For other themes: NAME is the full theme symbol like 'kuronami or 'wombat.
Returns nil if not a preset theme (wallpaper-based).
Uses caching for performance - pass FORCE-REFRESH to bypass cache."
  (let* ((cache-file (expand-file-name "~/.cache/wal/colors.json"))
         (preset-dir (expand-file-name "~/.config/wal/colorschemes/dark/")))
    (when (file-exists-p cache-file)
      ;; Check cache validity
      (if (and my/preset-theme-cache
               (not force-refresh)
               (equal (nth 5 (file-attributes cache-file))
                      (car my/preset-theme-cache)))
          ;; Return cached result
          (cdr my/preset-theme-cache)
        
        ;; Cache miss or expired - recompute
        (let* ((json-object-type 'alist)
               (json-array-type 'list)
               (current-colors (json-read-file cache-file))
               (current-bg (alist-get 'background (alist-get 'special current-colors)))
               (current-fg (alist-get 'foreground (alist-get 'special current-colors)))
               (current-c0 (alist-get 'color0 (alist-get 'colors current-colors)))
               (result nil))
          
          ;; Check all preset files for a match
          (catch 'found
            (dolist (file (directory-files preset-dir nil "\\.json$"))
              (let* ((preset-path (expand-file-name file preset-dir))
                     (preset-colors (json-read-file preset-path))
                     (preset-bg (alist-get 'background (alist-get 'special preset-colors)))
                     (preset-fg (alist-get 'foreground (alist-get 'special preset-colors)))
                     (preset-c0 (alist-get 'color0 (alist-get 'colors preset-colors))))
                
                ;; Match if bg, fg, and color0 all match
                (when (and (string= current-bg preset-bg)
                          (string= current-fg preset-fg)
                          (string= current-c0 preset-c0))
                  ;; Check if it's a doom theme or other theme
                  (setq result
                        (if (string-match "^doom-\\(.*\\)\\.json$" file)
                            ;; Doom theme: return ('doom . "gruvbox-light")
                            (cons 'doom (match-string 1 file))
                          ;; Other theme: return ('other . 'kuronami)
                          (cons 'other 
                                (intern (replace-regexp-in-string "\\.json$" "" file)))))
                  (throw 'found result)))))
          
          ;; Update cache with file timestamp and result
          (setq my/preset-theme-cache 
                (cons (nth 5 (file-attributes cache-file)) result))
          result)))))
(defun reload-pywal-theme ()
  "Reload theme - use original doom theme if preset, else use ewal.
Properly handles org-roam-ui websocket server to prevent port conflicts."
  (interactive)
  (let* ((colors-file (expand-file-name "~/.cache/wal/colors.json"))
         (json-object-type 'alist)
         (json-array-type 'list)
         (colors (json-read-file colors-file))
         (wallpaper (alist-get 'wallpaper colors))
         ;; Check if wallpaper is actual path (not "None" string)
         (is-wallpaper-based (and wallpaper 
                                  (not (string= wallpaper "None"))
                                  (file-exists-p wallpaper)))
         ;; Save org-roam-ui state before theme change
         (org-roam-ui-was-active (and (featurep 'org-roam-ui)
                                       (bound-and-true-p org-roam-ui-mode))))
    
    ;; Step 1: Stop org-roam-ui if running to prevent websocket port conflict
    (when org-roam-ui-was-active
      (org-roam-ui-mode -1)
      (message "Stopped org-roam-ui for theme reload..."))
    
    ;; Step 2: Disable all old themes first to avoid conflicts
    (mapc #'disable-theme custom-enabled-themes)
    
    ;; Step 3: Load the appropriate theme
    (if is-wallpaper-based
        ;; Wallpaper-based theme: use ewal with our fixes
        (progn
          (ewal-load-colors)
          (load-theme 'ewal-doom-one t)
          (message "Pywal theme reloaded (wallpaper-based)"))
      
      ;; No wallpaper or "None" = preset theme: try to load original theme
      ;; Force refresh cache since pywal colors just changed
      (let* ((preset-info (my/detect-preset-theme t))
             (preset-type (car preset-info))
             (preset-name (cdr preset-info)))
        (cond
         ;; Doom preset theme
         ((eq preset-type 'doom)
          (let ((theme-symbol (intern (concat "doom-" preset-name))))
            (if (member theme-symbol (custom-available-themes))
                (progn
                  (load-theme theme-symbol t)
                  (message "Loaded original doom theme: %s" theme-symbol))
              ;; Fallback to ewal if doom theme not found
              (progn
                (ewal-load-colors)
                (load-theme 'ewal-doom-one t)
                (message "Doom theme %s not found, using ewal" theme-symbol)))))
         
         ;; Other preset theme (kuronami, wombat, etc.)
         ((eq preset-type 'other)
          (if (member preset-name (custom-available-themes))
              (progn
                (load-theme preset-name t)
                (message "Loaded original theme: %s" preset-name))
            ;; Fallback to ewal if theme not found
            (progn
              (ewal-load-colors)
              (load-theme 'ewal-doom-one t)
              (message "Theme %s not found, using ewal" preset-name))))
         
         ;; No preset detected, use ewal
         (t
          (ewal-load-colors)
          (load-theme 'ewal-doom-one t)
          (message "Pywal theme reloaded (preset fallback to ewal)")))))
    
    ;; Step 4: Restart org-roam-ui if it was running before
    (when org-roam-ui-was-active
      ;; Small delay to ensure theme is fully loaded
      (run-at-time 0.3 nil 
                   (lambda ()
                     (org-roam-ui-mode 1)
                     (message "Restarted org-roam-ui after theme reload"))))))
#+end_src

** Transparency Toggle and Pywal Auto-Reload

Unified transparency system that syncs across kitty, st, and emacs.
Uses Super+Shift+P (via DWM) to toggle all windows simultaneously.
State is persisted in ~/.cache/transparency-state and copied to /tmp on startup.
#+begin_src emacs-lisp
;; Initialize transparency state (fast, runs synchronously on startup)
(let ((temp-state "/tmp/transparency-state")
      (persistent-state (expand-file-name "~/.cache/transparency-state")))
  ;; If temp state doesn't exist, restore from persistent or create default
  (unless (file-exists-p temp-state)
    (if (file-exists-p persistent-state)
        (copy-file persistent-state temp-state t)
      (with-temp-file temp-state (insert "transparent"))
      (with-temp-file persistent-state (insert "transparent")))))
;; Read transparency state from file (inline for speed)
(defun get-transparency-state ()
  "Read current transparency state from /tmp/transparency-state."
  (if (file-exists-p "/tmp/transparency-state")
      (with-temp-buffer
        (insert-file-contents "/tmp/transparency-state")
        (string-trim (buffer-string)))
    "transparent"))
;; Set initial transparency based on saved state
(let ((state (get-transparency-state)))
  (set-frame-parameter nil 'alpha-background 
                       (if (string= state "opaque") 100 85)))
;; Toggle function that syncs with system
(defun toggle-emacs-transparency ()
  "Toggle emacs frame transparency and sync with system state."
  (interactive)
  ;; Just call the system-wide toggle script which handles everything
  (start-process-shell-command 
   "toggle-transparency" nil "~/.config/scripts/system/toggle-transparency"))
;; Watch for transparency state changes from external toggles (async, no startup impact)
(when (functionp 'file-notify-add-watch)
  (let ((state-file "/tmp/transparency-state"))
    (file-notify-add-watch state-file '(change)
      (lambda (event)
        (when (eq (nth 1 event) 'changed)
          (let ((state (get-transparency-state)))
            (dolist (frame (frame-list))
              (set-frame-parameter frame 'alpha-background 
                                   (if (string= state "opaque") 100 85)))))))))
;; Watch for pywal color changes
(defvar my/pywal-reload-timer nil
  "Timer for debouncing pywal theme reloads.")
(defun my/watch-pywal-colors ()
  "Set up file watcher for pywal colors.json to auto-reload theme.
Debounced to prevent duplicate reloads when multiple hooks trigger."
  (when (functionp 'file-notify-add-watch)
    (let ((colors-file (expand-file-name "~/.cache/wal/colors.json")))
      (when (file-exists-p colors-file)
        (file-notify-add-watch colors-file '(change)
          (lambda (event)
            (when (eq (nth 1 event) 'changed)
              ;; Cancel existing timer to debounce
              (when my/pywal-reload-timer
                (cancel-timer my/pywal-reload-timer))
              ;; Set new timer - reload after 0.2s of no changes
              (setq my/pywal-reload-timer
                    (run-at-time 0.2 nil #'reload-pywal-theme)))))))))
;; Auto-enable the color watcher when emacs starts
(my/watch-pywal-colors)
#+end_src

** Theme Conversion Tools

Load the theme-to-pywal script only when needed (lazy-load for faster startup).
This provides commands like =M-x theme-to-pywal-generate-melpa-theme= for converting
newly installed themes.
#+begin_src emacs-lisp
;; Autoload theme conversion commands without loading the whole file
(autoload 'theme-to-pywal-generate-melpa-theme 
  (expand-file-name "~/.config/doom/theme-to-pywal.el")
  "Convert an installed Emacs theme to pywal JSON format." t)
(autoload 'theme-to-pywal-batch-generate-doom-themes
  (expand-file-name "~/.config/doom/theme-to-pywal.el")
  "Batch convert all Doom themes to pywal JSON presets." t)
#+end_src

* Org-Roam Configuration

My org-roam setup is designed for academic work, using a Zettelkasten-style
knowledge management system with concepts, lectures, readings, and projects.

** Org-Roam UI

Configure org-roam-ui for visual graph navigation of my knowledge base.
Note: org-roam-ui-sync-theme is disabled to prevent websocket port conflicts during
theme reloads, and to ensure better contrast in the web UI.
#+begin_src emacs-lisp
(use-package! org-roam-ui
  :after org-roam
  :hook (org-roam-mode . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme nil  ; Disabled to prevent port conflicts & ensure good contrast
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src

** Capture Templates

My capture templates support different types of content in my knowledge system:
- *Lectures* (=l=): Raw notes from lectures with post-processing checklist
- *Concepts* (=c=): Atomic concept nodes with definition, context, relations
- *Readings* (=rd=): Paper/book notes with citations
- *Recipes* (=r=): Recipe notes with ingredients and procedures
- *Assignments* (=a=): Coursework planning and tracking
- *Projects* (=p=): Personal project overviews
#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-v2-ack t)
  (setq org-roam-capture-templates
        '(("l" "Lecture quicknote" plain
           "%?\n* Post-Lecture Checklist\n- [ ] Extract definitions\n- [ ] Create/update concept node\n- [ ] Link readings\n- [ ] Mark processed"
           :if-new (file+head "academic/lectures/raw/%<%Y-%m-%d>-${slug}.org"
                              "#+TITLE: %<%Y-%m-%d> ${title} Lecture\n#+FILETAGS: :lecture:raw:\n")
           :unnarrowed t)
           ("c" "Concept node" plain
            "* Overview\n%?\n* Context\n* Relations\n* Applications\n* References"
            :if-new (file+head "concepts/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :concept:seed:\n")
            :unnarrowed t)
           ("rd" "Reading note" plain
            "* Summary\n%?\n* Key Claims\n* Methods\n* Critical Reflections\n* Links"
            :if-new (file+head "readings/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :reading:seed:\n:PROPERTIES:\n:ROAM_REFS: ${ref}\n:END:\n")
            :unnarrowed t)
           ("r" "Recipe" plain
            "* Ingredients\n\n- \n\n* Prep\n\n- \n\n* Procedure\n\n1. \n\n* Notes\n\n%?"
            :if-new (file+head "recipes/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :recipe:\n")
            :unnarrowed t)
          ("a" "Assignment plan" plain
           "* Brief\n%?\n* Requirements\n* Sources\n* Outline\n* Timeline\n* Status"
           :if-new (file+head "assignments/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :assignment:active:\n")
           :unnarrowed t)
           ("p" "Project node" plain
            "* Overview\n%?\n* Goals\n* Links\n* Decisions\n* TODO\n* Resources"
            :if-new (file+head "projects/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :project:active:\n")
            :unnarrowed t)))
  
  ;; Org-Roam Dailies Configuration
  (setq org-roam-dailies-directory "daily/")
  (setq org-roam-dailies-capture-templates
        '(("d" "Daily" entry
           "* <%<%Y-%m-%d %a %H:%M>>\n%?"
           :target (file+head "%<%Y-%m-%d>.org"
                              "#+TITLE: %<%B %d, %Y>\n#+FILETAGS: :daily:\n")))))
#+end_src

** Org-Roam Dailies

The dailies configuration is now integrated into the main org-roam configuration block above.

** Helper Functions

*** Promote Heading to Concept

This function extracts a heading from a lecture or inbox note and promotes it
to a standalone concept node. The heading's contents are copied into the new
concept file under the =* Overview= section, and a reference link to the original
heading is added to the concept's =* References= section. The original heading
is preserved (not deleted).
#+begin_src emacs-lisp
  (defun my/org-roam-promote-heading-to-concept ()
    "Promote current heading into a new concept node.
This:
- Creates `concepts/<slug>.org` (if missing) with a scaffold that uses '* Overview'.
- Copies the current heading's subtree (content below the heading line) into
  the new file under '* Overview' (appends).
- Transfers the original heading's ID to the new file (if it exists), so existing
  links to that heading automatically resolve to the new concept file.
- Removes the ID from the original heading to avoid duplicates.
- Inserts a link to the new concept in the original file's '* Relations' section as a bullet point.
It does NOT delete or replace the original heading." 
    (interactive)
    (unless (org-at-heading-p)
      (user-error "Not at a heading"))
    (let* ((title (nth 4 (org-heading-components)))
           (node (org-roam-node-create :title title))
           (slug (org-roam-node-slug node))
           (file (expand-file-name (format "concepts/%s.org" slug) org-roam-directory))
           ;; original subtree bounds
           (orig-beg (save-excursion (org-back-to-heading t) (point)))
           (orig-end (save-excursion (org-end-of-subtree t t)))
           ;; body = text after the heading line up to end of subtree
           (body (save-restriction
                   (widen)
                   (when (> orig-end orig-beg)
                     (save-excursion
                       (goto-char orig-beg)
                       (forward-line 1)
                       ;; Skip properties drawer if present
                       (when (looking-at "^[ \t]*:PROPERTIES:")
                         (when (re-search-forward "^[ \t]*:END:" orig-end t)
                           (forward-line 1)))
                       ;; Skip any blank lines after properties
                       (while (and (< (point) orig-end) (looking-at-p "^\\s-*$"))
                         (forward-line 1))
                       ;; Extract the actual content
                       (let ((content-start (point)))
                         (when (< content-start orig-end)
                           (string-trim (buffer-substring-no-properties content-start orig-end)))))))))
      ;; Ensure original heading has an ID so we can link to it later if needed
      (let ((orig-id (save-excursion
                       (org-back-to-heading t)
                       (or (org-entry-get nil "ID")
                           (org-id-get-create)))))
        ;; Create scaffold if file doesn't exist
        (unless (file-exists-p file)
          (with-temp-file file
            (insert ":PROPERTIES:\n:END:\n#+TITLE: " title "\n#+FILETAGS: :concept:seed:\n\n* Overview\n\n* Context\n* Relations\n* Applications\n* References\n")))
        ;; Transfer or create ID: use heading's existing ID if present, otherwise generate new one
        (let ((new-id (if orig-id
                          ;; Use the original heading's ID for the new file
                          (progn
                            (with-current-buffer (find-file-noselect file)
                              (goto-char (point-min))
                              (when (re-search-forward "^:PROPERTIES:" nil t)
                                (forward-line 1)
                                (insert (format ":ID: %s\n" orig-id)))
                              (save-buffer))
                            ;; Delete entire properties drawer from original heading
                            (save-excursion
                              (org-back-to-heading t)
                              (when (re-search-forward "^[ \t]*:PROPERTIES:" (save-excursion (outline-next-heading) (point)) t)
                                (let ((beg (line-beginning-position)))
                                  (when (re-search-forward "^[ \t]*:END:" (save-excursion (outline-next-heading) (point)) t)
                                    (delete-region beg (1+ (line-end-position)))))))
                            (save-buffer)
                            orig-id)
                        ;; No existing ID, generate a new one for the concept file
                        (let ((generated-id (org-id-new)))
                          (with-current-buffer (find-file-noselect file)
                            (goto-char (point-min))
                            (when (re-search-forward "^:PROPERTIES:" nil t)
                              (forward-line 1)
                              (insert (format ":ID: %s\n" generated-id)))
                            (save-buffer))
                          generated-id))))
          ;; Insert body into Overview if present
          (when (and body (not (string-empty-p (string-trim body))))
            (with-current-buffer (find-file-noselect file)
              (save-excursion
                (goto-char (point-min))
                (when (re-search-forward "^\\* Overview\\s-*$" nil t)
                  (forward-line 1)
                  ;; Clean up: remove any existing blank lines after Overview heading
                  (while (looking-at-p "^\\s-*$")
                    (delete-region (line-beginning-position) (1+ (line-end-position))))
                  ;; Insert the trimmed body content
                  (insert (string-trim body) "\n")
                  (save-buffer)))))
          ;; Insert a link to the NEW concept into the original file's *Relations section
          (save-excursion
            (goto-char (point-min))
            (if (re-search-forward "^\\* Relations\\s-*$" nil t)
                ;; Found Relations section, insert link
                (progn
                  (forward-line 1)
                  (insert (format "- [[id:%s][%s]]\n" new-id title))
                  (save-buffer))
              ;; No Relations section, create one at end of file
              (goto-char (point-max))
              (unless (bolp) (insert "\n"))
              (insert (format "* Relations\n- [[id:%s][%s]]\n" new-id title))
              (save-buffer)))
           (message "Promoted '%s' → %s (id:%s) and inserted link in original file" title file new-id)))))
#+end_src

*** Insert File Link

Insert a link to an external file (useful for linking to project files, GitHub repos, etc).
#+begin_src emacs-lisp
  (defun my/insert-file-link (path)
    "Insert an org file link to PATH with basename as description."
    (interactive "fFile: ")
    (insert (format "[[file:%s][%s]]" (abbreviate-file-name path) (file-name-base path))))
#+end_src

*** Add Heading ID

Add a UUID to a heading with a human-readable alias for easier referencing.
#+begin_src emacs-lisp
  (defun my/add-heading-id ()
    "Add org-id UUID to heading with filename-heading alias for org-roam."
    (interactive)
    (org-back-to-heading t)
    (let* ((filename (file-name-base (buffer-file-name)))
           (title (nth 4 (org-heading-components)))
           (alias (format "%s - %s" filename title))
           (id (org-id-get-create)))
      (org-set-property "ROAM_ALIASES" (format "\"%s\"" alias))
      (message "Added ID with alias: %s" alias)))
#+end_src

*** Insert Heading Link

Interactive function to pick an org file and heading, then insert a link with proper ID.
#+begin_src emacs-lisp
  (defun my/insert-heading-link ()
    "Pick an org file recursively, then link to a heading with org-id."
    (interactive)
    (let* ((current-buf (current-buffer))
           (brain2-dir (expand-file-name "~/Documents/brain2/"))
           (default-directory brain2-dir)
           ;; Get all org files recursively
           (org-files (directory-files-recursively brain2-dir "\\.org$"))
           ;; Make paths relative for cleaner display
           (file-choices (mapcar (lambda (f) (file-relative-name f brain2-dir)) org-files))
           (file-rel (completing-read "Org file: " file-choices nil t))
           (file (expand-file-name file-rel brain2-dir))
           (filename (file-name-base file)))
      (unless (file-exists-p file)
        (user-error "File not found: %s" file))
      ;; List headings in that file
      (with-current-buffer (find-file-noselect file)
        (let* ((headings (org-map-entries (lambda () (nth 4 (org-heading-components))) nil 'file))
               (heading (completing-read "Heading: " headings)))
          ;; Find the heading and get/create its ID
          (goto-char (point-min))
          (unless (search-forward heading nil t)
            (user-error "Heading not found: %s" heading))
          (org-back-to-heading t)
          (let* ((id (org-id-get-create))
                 (alias (format "%s - %s" filename heading))
                 (link (format "[[id:%s][%s]]" id heading)))
            ;; Ensure alias is set
            (unless (org-entry-get nil "ROAM_ALIASES")
              (org-set-property "ROAM_ALIASES" (format "\"%s\"" alias)))
            ;; Switch back to original buffer and insert link
            (with-current-buffer current-buf
              (insert link)
              (message "Inserted link: %s" link)))))))
#+end_src

** Keybindings

All org-roam related keybindings are under the =SPC n= prefix.
#+begin_src emacs-lisp
  (map! :leader
        :desc "Promote heading to concept" "n P" #'my/org-roam-promote-heading-to-concept
        :desc "Insert file link" "n f" #'my/insert-file-link
        :desc "Add heading ID" "n i" #'my/add-heading-id
        :desc "Insert heading link" "n h" #'my/insert-heading-link
        :desc "Find/create node" "n n" #'org-roam-node-find
        :desc "Insert node link" "n l" #'org-roam-node-insert
        :desc "Toggle backlinks" "n b" #'org-roam-buffer-toggle
        :desc "Open graph UI" "n g" #'org-roam-ui-open
        :desc "Capture new node" "n c" #'org-roam-capture)
#+end_src

** Buffer Navigation

Keybindings for cycling through buffers with Alt+Shift+H/L.
We need to unbind evil-org-mode's bindings which override the global ones.
#+begin_src emacs-lisp
;; Unbind evil-org-mode's M-H and M-L bindings
(after! evil-org
  (map! :map evil-org-mode-map
        :nvi "M-H" nil
        :nvi "M-L" nil))
;; Now set our buffer navigation bindings
(map! :nvi "M-H" #'previous-buffer
      :nvi "M-L" #'next-buffer)
#+end_src

* Lecture Processing

Helper function to mark a lecture as processed and move it from =raw/= to =processed/=.
#+begin_src emacs-lisp
(defun my/mark-lecture-processed ()
  "Mark current lecture note as processed and move to processed directory."
  (interactive)
  (let* ((file (buffer-file-name))
         (rel (file-relative-name file org-roam-directory)))
    (unless (string-match-p "academic/lectures/raw/" rel)
      (user-error "Not in raw lectures directory"))
    (save-excursion
      (goto-char (point-min))
      (unless (re-search-forward "POST-LECTURE CHECKLIST" nil t)
        (goto-char (point-max)))
      (save-buffer)
      (org-set-property "PROCESSED" (format-time-string "%Y-%m-%d")))
    (let* ((dest (expand-file-name (concat "academic/lectures/processed/" (file-name-nondirectory file)) org-roam-directory)))
      (rename-file file dest 1)
      (find-file dest)
      (message "Lecture processed & moved."))))
(map! :leader :desc "Process lecture" "n L" #'my/mark-lecture-processed)
#+end_src

* File Navigation

Use =consult-fd= for live, telescope-like file finding without caching.
#+begin_src emacs-lisp
;; SPC SPC - Find file in current project/directory (fast)
(map! :leader :desc "Find file (project)" "SPC" #'consult-fd)
;; SPC f f - Find file from home directory (fast, can type / for root)
(defun my/consult-fd-from-home ()
  "Find file using consult-fd starting from home directory."
  (interactive)
  (let ((default-directory "~")
        (projectile-require-project-root nil))
    (consult-fd)))
;; SPC f d - Find directory with consult-dir (built-in, fast)
(map! :leader
      :prefix "f"
      :desc "Find file from home" "f" #'my/consult-fd-from-home
      :desc "Find directory" "d" #'consult-dir)
#+end_src

** Performance: Fast Search Tools

Configure Emacs to use modern fast tools (fd, ripgrep) for all search operations.
#+begin_src emacs-lisp
;; Use fd instead of find for projectile
(after! projectile
  (when (executable-find "fd")
    (setq projectile-git-command "fd . -0 --type f --color=never"
          projectile-generic-command "fd . -0 --type f --color=never"
          projectile-indexing-method 'alien
          projectile-enable-caching nil)))  ; No cache needed with fd
;; Use ripgrep for project search
(after! counsel
  (when (executable-find "rg")
    (setq counsel-rg-base-command "rg --no-heading --line-number --color never %s .")))
;; Configure consult to use ripgrep and fd
(after! consult
  (when (executable-find "rg")
    (setq consult-ripgrep-args "rg --null --line-buffered --color=never --max-columns=1000 --path-separator / --smart-case --no-heading --with-filename --line-number --search-zip"))
  (when (executable-find "fd")
    (setq consult-fd-args "fd --color=never --full-path --hidden --exclude .git")))
;; Use ripgrep for Doom's default search
(after! vertico
  (when (executable-find "rg")
    (setq +default-want-RET-continue-p nil)))
#+end_src

** Yazi Integration (eee.el)

Launch yazi file manager in external terminal with Emacs integration.
#+begin_src emacs-lisp
(use-package! eee
  :config
  ;; Use suckless terminal for yazi and other TUI tools
  (setq ee-terminal-command "st")
  
  ;; Keybindings for yazi and other TUI tools
  (map! :leader
        :desc "Yazi (current dir)" "f y" #'ee-yazi
        :desc "Yazi (project)" "f Y" #'ee-yazi-project
        :desc "Ripgrep search" "s g" #'ee-rg
         :desc "Lazygit" "g z" #'ee-lazygit))
#+end_src

** Dired Configuration

Improve dired usability with better clipboard commands.
- Press ~y Y~ in dired to copy file itself to clipboard (for pasting into apps like Discord)
#+begin_src emacs-lisp
(after! dired
  (defun my/dired-copy-file-to-clipboard ()
    "Copy the file at point to system clipboard for pasting into applications."
    (interactive)
    (let ((file (dired-get-filename)))
      (if (file-directory-p file)
          (message "Cannot copy directory to clipboard")
        (let* ((mime-type (string-trim
                           (shell-command-to-string
                            (format "file --mime-type -b %s" (shell-quote-argument file)))))
               (cmd (format "xclip -selection clipboard -t %s -i %s"
                            mime-type
                            (shell-quote-argument file))))
          (call-process-shell-command cmd nil 0)
          (message "Copied file to clipboard: %s" (file-name-nondirectory file))))))
  
  (map! :map dired-mode-map
        :n "y Y" #'my/dired-copy-file-to-clipboard))
#+end_src

* Rust Configuration

Configure rust-analyzer to use the correct sysroot from rustup.
#+begin_src emacs-lisp
(after! rustic
  (setq lsp-rust-analyzer-server-display-inlay-hints t
        lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial"
        lsp-rust-analyzer-display-parameter-hints t
        lsp-rust-analyzer-display-closure-return-type-hints t))
(after! eglot
  ;; Set up environment for rust-analyzer
  (setenv "PATH" (concat (expand-file-name "~/.cargo/bin") ":" (getenv "PATH")))
  (setenv "RUSTUP_TOOLCHAIN" "stable-x86_64-unknown-linux-gnu")
  
  ;; Suppress EGLOT sentinel warnings for unresponsive servers
  ;; These warnings are harmless but noisy - we let EGLOT handle cleanup silently
  (setq eglot-extend-to-xref nil)
  (advice-add 'eglot--warn :around
    (lambda (orig-func &rest args)
      ;; Silence sentinel warnings about unresponsive servers
      (unless (and (> (length args) 0)
                   (stringp (car args))
                   (string-match "Sentinel for EGLOT.*still hasn't run" (car args)))
        (apply orig-func args))))
  
  (add-to-list 'eglot-server-programs
    '((rust-ts-mode rust-mode) .
      ("rust-analyzer" :initializationOptions
       (:checkOnSave t
        :procMacro (:enable t)
        :cargo (:buildScripts (:enable t)))))))
#+end_src

* AI Integration: Copilot

Real-time code completion using GitHub Copilot.
#+begin_src emacs-lisp
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)
              ("M-f" . 'copilot-accept-completion-by-word)
              ("M-n" . 'copilot-next-completion)
              ("M-p" . 'copilot-previous-completion))
  :config
  (setq copilot-indent-offset-alist '((prog-mode . 2)
                                      (org-mode . 2)
                                      (emacs-lisp-mode . 2)
                                      (python-mode . 4)
                                      (rust-mode . 4)))
  
  ;; Silence copilot indentation warning for non-programming modes
  (defun copilot--infer-indentation-offset ()
    "Infer indentation offset, silently return nil if no standard indent found."
    (let ((indent-size
           (or (and (eq major-mode 'python-mode) 4)
               (and (eq major-mode 'rust-mode) 4)
               (and (eq major-mode 'go-mode) 8)
               (and (eq major-mode 'c++-mode) 2)
               (and (eq major-mode 'c-mode) 2)
               (and (eq major-mode 'java-mode) 4)
               (and (eq major-mode 'js-mode) 2)
               (and (eq major-mode 'typescript-mode) 2)
               (and (eq major-mode 'emacs-lisp-mode) 2)
               (and (eq major-mode 'lisp-mode) 2)
               (and (eq major-mode 'scheme-mode) 2)
               (and (eq major-mode 'clojure-mode) 2)
               (and (eq major-mode 'ruby-mode) 2)
               2))) ; Default to 2 without warning
      indent-size))
  
  ;; Custom TAB handler for Evil insert state
  (defun my/copilot-tab-or-default ()
    (interactive)
    (cond
     ((and (bound-and-true-p copilot-mode)
           (copilot--overlay-visible-p))
      (copilot-accept-completion))
     ((and (featurep 'corfu)
           corfu--visible)
      (corfu-next))
     (t
      (insert "\t"))))
  (after! evil
    (evil-define-key 'insert 'global (kbd "<tab>") #'my/copilot-tab-or-default)
    (evil-define-key 'insert 'global (kbd "TAB") #'my/copilot-tab-or-default)))
#+end_src

* AI Integration: GPTel

GPTel provides AI assistance directly in Emacs.
#+begin_src emacs-lisp
(use-package! gptel
  :config
  (setq gptel-model 'gpt-5-mini
        gptel-backend (gptel-make-gh-copilot "Copilot")
        gptel-default-mode 'org-mode)
  
  ;; Preset for org-roam PKM work with psychology studies
  (gptel-make-preset 'brain2beta
    :description "Org-roam PKM assistant for psychology studies"
    :backend "Copilot"
    :model 'gpt-4.1
    :system "You are a large language model living in my DOOM Emacs and a helpful assistant. We are currently operating within my org-roam based PKM, which I am learning to use to manage my life studying psychology and my interests. Respond concisely."
    :stream t
    :temperature 1.0
    :include-reasoning t
    :use-context 'system))
#+end_src
To use GPTel:
- =M-x gptel= -- Open a chat buffer
- =M-x gptel-menu= -- Select model/backend
- =C-u C-c RET= -- Open options menu to switch presets
- In org-mode, select region and send to gptel for processing

** GPTel Agent

GPTel Agent extends gptel with autonomous agent capabilities - the LLM can take actions,
browse the web, read/write files, and execute code. Requires gptel to be up to date.
#+begin_src emacs-lisp
(use-package! gptel-agent
  :after gptel
  :commands (gptel-agent)
  :config
  ;; Initialize agent tools and capabilities
  (gptel-agent-update))
  
  ;; Optional: Configure agent directories for custom sub-agents
  ;; (add-to-list 'gptel-agent-dirs "~/path/to/custom/agents")
;; Keybinding for gptel-agent (set globally, not in use-package)
(map! :leader
      :prefix "o"
      :desc "GPTel Agent" "l c" #'gptel-agent)
#+end_src
To use GPTel Agent:
- =M-x gptel-agent= -- Open a dedicated agent session in current project
- =C-u M-x gptel-agent= -- Open with prefix for more options
- Include =@gptel-agent= in any gptel prompt to use agent capabilities in any buffer
- Switch between presets: agent mode (full autonomy) and planning mode (read-only)

* Discord Presence

Show your Emacs activity on Discord using emacs-rpc.
Lazy-loaded to avoid startup overhead.
#+begin_src emacs-lisp
(use-package! presence
  :defer 5  ; Load 5 seconds after startup (lazy-load for performance)
  :commands (presence-mode)
  :init
  ;; Don't auto-enable, let it load lazily
  (run-with-idle-timer 5 nil #'presence-mode)
  :config
  ;; Use custom Discord application
  (setq presence-client-id "1443438985878962228")
  ;; Use asset keys directly (not URLs) for our custom Discord app
  (setq presence-icon-base nil)
  ;; Override to return just the asset key
  (defun presence--resolve-icon-base (icon)
    "Return just the icon asset key for Discord."
    icon)
  ;; Use custom icon from our Discord app
  (setq presence-editor-icon "emacs-icon")
  ;; Keep editor as main icon, mode as small icon
  (setq presence-use-major-mode-as-main-icon nil)
  ;; Show the small icon (mode icon)
  (setq presence-show-small-icon t)
  ;; Add extra mode icon mappings
  (setq presence-mode-icon-alist
        (append '((magit-status-mode . "git")
                  (magit-log-mode . "git")
                  (magit-diff-mode . "git")
                  (magit-revision-mode . "git")
                  (conf-toml-mode . "toml"))
                presence-mode-icon-alist))
  ;; Hide line numbers from status
  (setq presence-display-line-numbers nil)
  ;; Custom format: show project name + file instead of just buffer name
  (defun my/presence-buffer-details ()
    (let ((project (projectile-project-name))
          (file (buffer-name)))
      (if (and project (not (string= project "-")))
          (format "In %s: %s" project file)
        (format "Editing %s" file))))
  (setq presence-buffer-details-format-function #'my/presence-buffer-details))
#+end_src

* Org-Todo

Configure todo keywords for different task types.
#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords
        '((sequence "TODO(t)" "PROJ(p)" "LOOP(l)" "SKILL(s)" "|" "DONE(d)" "KILL(k)")))
  
  ;; Add CLOSED timestamp when marking TODO as DONE
  (setq org-log-done 'time))
#+end_src

* Org Agenda

Single-page agenda overview tuned to my `inbox.org` workflow.
#+begin_src emacs-lisp
(setq org-agenda-start-with-log-mode t)
(after! org-agenda
  (setq org-agenda-files '("~/Documents/brain2/")
        org-hide-emphasis-markers t
        org-agenda-compact-blocks t
        org-agenda-block-separator ?─)
  ;; Use nerd-icons for priority symbols if you want (commented out by default)
  ;; (setq org-priority-highest ?A
  ;;       org-priority-lowest ?C
  ;;       org-priority-default ?B)
  ;; Use Doom's default Evil behavior in Agenda (motion state).
  ;; `evil-org-agenda` defines most of Doom's agenda-friendly bindings in
  ;; motion state; forcing `normal` makes keys like `q` fall back to Evil's
  ;; macro recording.
  (set-evil-initial-state! 'org-agenda-mode 'motion)
  ;; Some agenda views (e.g. `alltodo`, often used for overview dashboards)
  ;; can end up using Org's default `org-agenda-mode-map` bindings.
  ;; Ensure `j/k` always move by line (Doom-style).
  (define-key org-agenda-mode-map (kbd "j") #'org-agenda-next-line)
  (define-key org-agenda-mode-map (kbd "k") #'org-agenda-previous-line)
  ;; Fallback: ensure emphasis markers are hidden when org-mode starts
  (add-hook 'org-mode-hook (lambda () (setq org-hide-emphasis-markers t)))
  ;; Custom agenda commands
  (setq org-agenda-custom-commands
        '(("o" "Overview"
           alltodo ""
           ((org-agenda-overriding-header "Active Tasks")
            (org-agenda-skip-function
             (lambda ()
               (let ((file (buffer-file-name)))
                 ;; Skip items in Archive section
                 (when (save-excursion
                         (org-back-to-heading t)
                         (let ((path (org-get-outline-path)))
                           (member "Archive" path)))
                   (org-end-of-subtree t)))))
            (org-super-agenda-groups
             '((:name "Overdue" :deadline past :order 1)
               (:name "Today" :scheduled today :deadline today :order 2)
               (:name "This Week"
                :pred (lambda (item)
                        (org-super-agenda--when-with-marker-buffer (org-super-agenda--get-marker item)
                          (let ((sched (org-entry-get (point) "SCHEDULED"))
                                (dead (org-entry-get (point) "DEADLINE")))
                            (or (and sched
                                     (let ((sched-abs (org-time-string-to-absolute sched)))
                                       (and (> sched-abs (org-today))
                                            (< sched-abs (+ (org-today) 7)))))
                                (and dead
                                     (let ((dead-abs (org-time-string-to-absolute dead)))
                                       (and (> dead-abs (org-today))
                                            (< dead-abs (+ (org-today) 7)))))))))
                :order 3)
               (:name "High Priority (A)" :priority "A" :order 4)
               (:name "Medium Priority (B)" :priority "B" :order 5)
               (:name "Projects" :todo "PROJ" :order 6)
               (:name "Recurring" :todo "LOOP" :order 7)
               (:name "Unscheduled TODOs" :and (:todo "TODO" :not (:scheduled t :deadline t)) :order 8)
               (:discard (:todo ("DONE" "KILL")))))))
          ("t" "Today"
           agenda ""
           ((org-agenda-span 'day)
            (org-deadline-warning-days 0)
            (org-agenda-start-with-log-mode nil)
            (org-super-agenda-groups
             '((:name "Scheduled Today" :scheduled today :order 1)
               (:name "Due Today" :deadline today :order 2)
               (:name "Overdue" :deadline past :order 3)))))
          ("w" "This Week"
           agenda ""
           ((org-agenda-span 7)
            (org-deadline-warning-days 0)
            (org-agenda-start-with-log-mode nil)
            (org-super-agenda-groups
             '((:name "Overdue" :deadline past :order 1)
               (:name "Today" :scheduled today :deadline today :order 2)
               (:name "This Week" :scheduled (next 7 days) :deadline (next 7 days) :order 3))))))))
(use-package! org-super-agenda
  :after org-agenda
  :config
  ;; `org-super-agenda` applies a separate keymap to group headers.
  ;; Ensure it stays in sync with the agenda buffer's map so `j/k`
  ;; behave the same on headers and items.
  (setq org-super-agenda-header-map org-agenda-mode-map
        org-super-agenda-header-prefix "  "
        org-super-agenda-header-separator "")
  (org-super-agenda-mode 1))
(defun my/org-agenda-skip-unless-top-level (top-level-heading)
  "Skip entry unless it is under TOP-LEVEL-HEADING."
  (let ((path (ignore-errors (org-get-outline-path t t))))
     (unless (and (consp path) (string= (car path) top-level-heading))
       (or (outline-next-heading) (point-max)))))
#+end_src

* Google Calendar Integration

Configure org-gcal to sync org-mode events with Google Calendar.
This setup prioritizes *pushing* events TO Google Calendar from org-mode.
Doom already provides calfw integration, we just need to configure org-gcal.

** Setup Instructions

1. Create Google Cloud Project and OAuth credentials:
   - Go to https://console.cloud.google.com/
   - Create a new project (or use existing)
   - Enable Google Calendar API
   - Create OAuth 2.0 credentials (Desktop app)
   - Download the JSON credentials
2. Store your credentials securely:
   - Credentials stored in =~/.config/doom/.secrets/gcal-oauth.el= (not in git)
   - Token will be stored in =~/.config/doom/.local/org-gcal/=

** Configuration

Load credentials early (before org-gcal loads):
#+begin_src emacs-lisp
;; Load Google Calendar OAuth credentials BEFORE org-gcal initializes
;; This prevents "must set client-id and client-secret" errors on fresh restart
(let ((secrets-file (expand-file-name "~/.config/doom/.secrets/gcal-oauth.el")))
  (when (file-exists-p secrets-file)
    (load secrets-file)))
#+end_src

Configure org-gcal with push-only mode:
#+begin_src emacs-lisp
(after! org-gcal
  ;; Set local timezone for proper time conversion (CRITICAL!)
  (setq org-gcal-local-timezone "Europe/London")
  
  ;; Set calendar location for Emacs calendar
  (setq calendar-location-name "London, UK"
        calendar-latitude 51.5
        calendar-longitude -0.1
        calendar-time-zone 0           ; GMT offset (0 minutes)
        calendar-standard-time-zone-name "GMT"
        calendar-daylight-time-zone-name "BST")
  
  ;; Map inbox.org to Google Calendar - sync scheduled/deadline events
  (setq org-gcal-fetch-file-alist '(("hugo.serranochan@gmail.com" . "~/Documents/brain2/inbox.org"))
        org-gcal-auto-local-sync t)
  
  ;; Wrapper that auto-sets calendar-id before posting (avoids prompt)
  (defun my/org-gcal-post-with-calendar-id ()
    "Post entry to Google Calendar, auto-setting calendar-id if missing."
    (interactive)
    (save-excursion
      (org-back-to-heading t)
      ;; Auto-add calendar-id property if missing
      (unless (org-entry-get (point) "calendar-id")
        (org-entry-put (point) "calendar-id" "hugo.serranochan@gmail.com"))
      ;; Now post the event
      (org-gcal-post-at-point)))
  
  ;; Auto-sync hooks: Push to Google Calendar on save/capture
  (add-hook 'org-capture-after-finalize-hook 'org-gcal-sync)
  (add-hook 'org-archive-hook 'org-gcal-sync))
#+end_src

Keybindings for calendar operations (always available, autoload org-gcal when used):
#+begin_src emacs-lisp
(map! :leader
      :prefix "o"
      :desc "Open calendar view" "c" #'+calendar/open-calendar
      :desc "Fetch from Google Calendar" "g f" #'org-gcal-fetch
      :desc "Post event to Calendar" "g p" (cmd! (require 'org-gcal) (my/org-gcal-post-with-calendar-id))
      :desc "Delete Calendar event" "g d" (cmd! (require 'org-gcal) (org-gcal-delete-at-point)))
#+end_src

** Calfw Theme Integration

Make calfw match your Doom theme for better readability:
#+begin_src emacs-lisp
(after! calfw
  ;; Theme-aware faces for better readability with pywal/doom themes
  (custom-set-faces!
   ;; Main calendar title
   '(cfw:face-title :inherit font-lock-keyword-face :height 1.5 :weight bold)
   
   ;; Header (day names)
   '(cfw:face-header :inherit font-lock-function-name-face :weight bold)
   
   ;; Date grid
   '(cfw:face-grid :inherit shadow)
   
   ;; Today's date highlight
   '(cfw:face-today :background nil :foreground nil :weight bold 
     :inherit (highlight font-lock-constant-face))
   
   ;; Default day titles
   '(cfw:face-day-title :inherit default)
   
   ;; Sunday
   '(cfw:face-sunday :inherit font-lock-warning-face :weight bold)
   
   ;; Saturday
   '(cfw:face-saturday :inherit font-lock-type-face :weight bold)
   
   ;; Events/content
   '(cfw:face-default-content :inherit font-lock-string-face)
   
   ;; Multi-day events
   '(cfw:face-periods :inherit font-lock-keyword-face :slant italic)
   
   ;; Selected date
   '(cfw:face-select :background nil :inherit region)
   
   ;; Holidays
   '(cfw:face-holiday :inherit font-lock-warning-face)
   
   ;; Toolbar
   '(cfw:face-toolbar :inherit mode-line)
   '(cfw:face-toolbar-button-off :inherit mode-line-inactive)
   '(cfw:face-toolbar-button-on :inherit mode-line :weight bold)))
#+end_src

** Usage

- Create events in org-mode with timestamps: =SCHEDULED: <2025-01-15 Wed 14:00-15:00>=
- Save the file → automatically syncs to Google Calendar
- View calendar: =SPC o c=
- Manual sync: =SPC o g s=
- Post single event: =SPC o g p= (with cursor on event)
- Delete event: =SPC o g d= (removes from both org and Google Calendar)

* Org-Pomodoro Configuration

Configure org-pomodoro for the Pomodoro technique with manual break support.
The manual-break feature allows you to work a few minutes "overtime" to finish a task
before manually triggering the break by calling ~org-pomodoro~ again.
Notifications are sent via dunst (libnotify): one when entering overtime, one when break finishes.
#+begin_src emacs-lisp
;; Ensure DBUS session bus is set for notifications to work
(unless (getenv "DBUS_SESSION_BUS_ADDRESS")
  (let ((dbus-addr (format "unix:path=/run/user/%d/bus" (user-uid))))
    (when (file-exists-p (substring dbus-addr 10))
      (setenv "DBUS_SESSION_BUS_ADDRESS" dbus-addr))))
(use-package! alert
  :config
  ;; Configure alert to use libnotify (dunst) for org-pomodoro notifications
  (setq alert-default-style 'libnotify))
(use-package! org-pomodoro
  :after org
  :config
  ;; Enable manual break workflow: break won't auto-start, you control when it begins
  (setq org-pomodoro-manual-break t
        
        ;; Disable all sounds - use notifications only
        org-pomodoro-play-sounds nil
        org-pomodoro-start-sound-p nil
        org-pomodoro-finished-sound-p nil
        org-pomodoro-overtime-sound-p nil
        org-pomodoro-short-break-sound-p nil
        org-pomodoro-long-break-sound-p nil
        org-pomodoro-ticking-sound-p nil
        
        ;; Only clock work time, not breaks
        org-pomodoro-clock-break nil
        
        ;; Pomodoro and break durations (customize as needed)
        org-pomodoro-length 25
        org-pomodoro-short-break-length 5
        org-pomodoro-long-break-length 20
        org-pomodoro-long-break-frequency 4)
  
  ;; Override org-pomodoro-notify to disable built-in notifications
  ;; (we handle notifications via hooks instead)
  (defun org-pomodoro-notify (title message)
    "Disabled - we use custom hooks for notifications instead."
    nil)
  
  ;; Notification when entering overtime
  (defun my/org-pomodoro-overtime-notify ()
    "Send notification when overtime starts."
    (alert "Finished, overtime started" :title "Pomodoro" :category 'org-pomodoro))
  
  ;; Notification when breaks finish
  (defun my/org-pomodoro-short-break-finished-notify ()
    "Send notification when short break finishes."
    (alert "Short break finished" :title "Pomodoro" :category 'org-pomodoro))
  
  (defun my/org-pomodoro-long-break-finished-notify ()
    "Send notification when long break finishes."
    (alert "Long break finished" :title "Pomodoro" :category 'org-pomodoro))
  
  ;; Hook notifications into org-pomodoro events (only specific hooks to avoid duplicates)
  (add-hook 'org-pomodoro-overtime-hook
    (lambda () (my/org-pomodoro-overtime-notify)))
  
  (add-hook 'org-pomodoro-short-break-finished-hook
    (lambda () (my/org-pomodoro-short-break-finished-notify)))
  
  (add-hook 'org-pomodoro-long-break-finished-hook
    (lambda () (my/org-pomodoro-long-break-finished-notify)))
  
  ;; Keybinding for quick pomodoro access
  (map! :leader
        :desc "Start/stop pomodoro" "o p" #'org-pomodoro))
#+end_src

* Org Formatting

Simple, clean formatting for org files:
- Heading, then immediately PROPERTIES (if any)
- Then immediately SCHEDULED/DEADLINE (if any)
- Then ONE blank line before body content (if any)
- ONE blank line before next heading at same/higher level
#+begin_src emacs-lisp
(after! org
  ;; Set up org-capture templates for inbox
  (setq org-capture-templates
        '(("i" "Inbox TODO" entry
           (file+olp "~/Documents/brain2/inbox.org" "Global")
           "** TODO %?\n"
           :empty-lines 1)
          ("w" "Weekly TODO" entry
           (file+olp "~/Documents/brain2/inbox.org" "This Week")
           "** TODO %?\n"
           :empty-lines 1)))
  
  (defun my/org-format-buffer ()
    "Format org buffer with consistent, clean spacing matching example.org style."
    (interactive)
    (save-excursion
      ;; First, remove ALL blank lines in entire buffer
      (goto-char (point-min))
      (while (re-search-forward "\n\n+" nil t)
        (replace-match "\n"))
      
      ;; Add blank line after title/filetags section
      (goto-char (point-min))
      (when (re-search-forward "^#\\+\\(TITLE\\|FILETAGS\\):" nil t)
        (forward-line 1)
        (while (looking-at "^#\\+")
          (forward-line 1))
        (when (looking-at "^:PROPERTIES:")
          (re-search-forward "^:END:" nil t)
          (forward-line 1))
        (when (looking-at "^\\*")
          (insert "\n")))
      
      ;; Process all headings
      (goto-char (point-min))
      (while (re-search-forward "^\\(\\*+\\) " nil t)
        (forward-line 1)
        (when (looking-at "^[ \t]*:PROPERTIES:")
          (re-search-forward "^[ \t]*:END:" nil t)
          (forward-line 1))
        (while (looking-at "^[ \t]*\\(SCHEDULED:\\|DEADLINE:\\|CLOSED:\\)")
          (forward-line 1))
        (when (looking-at "^[ \t]*:LOGBOOK:")
          (re-search-forward "^[ \t]*:END:" nil t)
          (forward-line 1))
        (let ((content-start (point)))
          (cond
           ((eobp)
            (insert "\n"))
           ((looking-at "^\\*")
            (insert "\n"))
           (t
            (goto-char content-start)
            (insert "\n")
            (if (re-search-forward "^\\*" nil t)
                (progn
                  (beginning-of-line)
                  (insert "\n")
                  (beginning-of-line))
              (goto-char (point-max))
              (unless (bolp)
                (insert "\n")))))))
      
      ;; Add blank lines before attachment links (but not after captions)
      (goto-char (point-min))
      (while (re-search-forward "^\\[\\[attachment:" nil t)
        (beginning-of-line)
        ;; Check if previous line is not blank and not an italic caption
        (unless (or (bobp)
                    (save-excursion
                      (forward-line -1)
                      (or (looking-at "^[ \t]*$")
                          (looking-at "^/"))))
          (insert "\n"))
        (forward-line 1))
      
      ;; Add blank lines after italic captions (when followed by attachment or body text)
      (goto-char (point-min))
      (while (re-search-forward "^/.+/$" nil t)
        (forward-line 1)
        ;; Add blank line if next line exists and is not blank and not a heading
        (unless (or (eobp)
                    (looking-at "^[ \t]*$")
                    (looking-at "^\\*"))
          (insert "\n")))
      
      ;; Clean up trailing blank lines
      (goto-char (point-max))
      (while (and (> (point) 1)
                  (eq (char-before) ?\n)
                  (eq (char-before (1- (point))) ?\n))
        (delete-char -1))))
   
   ;; Enable auto-format on save
    (add-hook 'org-mode-hook
      (lambda ()
        (add-hook 'before-save-hook #'my/org-format-buffer nil t)))
   )
#+end_src

* Org Inline Images

Optimize inline image display performance by limiting the display width.
This dramatically reduces lag when scrolling past large screenshots (e.g., 1920x1080).
Images are displayed at max 800px width while the full-resolution files remain unchanged.
To view the full resolution, open the image externally with =RET= on the link.
#+begin_src emacs-lisp
(after! org
  ;; Display images at max 800px width instead of full resolution
  ;; This reduces rendering overhead for large screenshots
  (setq org-image-actual-width 600)
  (setq org-image-align 'center))
#+end_src

* Zen Mode Customization

Configure zen mode (writeroom-mode) with variable-pitch font for comfortable prose writing.
#+begin_src emacs-lisp
(setq +zen-text-scale 1)           ;; Font size scale (1 = one size larger for readability)
(setq writeroom-width 65)          ;; Column width (45 text columns = ~55 char margins on each side)
;; Configure org-modern to always be on for org-mode
(after! org-modern
  (setq org-modern-fold-stars '(("∵" . "∴"))
        org-modern-hide-stars 'leading)
  ;; Enable org-modern globally
  (add-hook 'org-mode-hook #'org-modern-mode))
;; Zen mode hook - enable variable-pitch, hide line numbers
(add-hook 'writeroom-mode-hook
  (lambda ()
    (if writeroom-mode
        (progn
          (display-line-numbers-mode -1)
          (when (derived-mode-p 'org-mode)
            (setq-local org-modern-hide-stars t)
            (variable-pitch-mode 1))  ; Use proportional font for prose
          (text-scale-set 2))  ; Larger font for comfortable reading
      (progn
        ;; Restore when exiting zen mode
        (display-line-numbers-mode 1)
        (when (derived-mode-p 'org-mode)
          (setq-local org-modern-hide-stars 'leading)
          (variable-pitch-mode -1))))))
#+end_src

* Dashboard Customization

#+begin_src emacs-lisp
;; Use custom Emacs logo as dashboard banner (300x300 Lanczos-smoothed)
(setq +doom-dashboard-banner-file "emacs-logo-300-smooth.xpm")
;; Dashboard menu sections
(setq +doom-dashboard-menu-sections
      '(("Open project"
         :icon (nerd-icons-devicon "nf-dev-git" :face 'doom-dashboard-menu-title :height 1.3)
         :action projectile-switch-project)
        ("Open documentation"
         :icon (nerd-icons-faicon "nf-fa-book_atlas" :face 'doom-dashboard-menu-title :height 1.3)
         :action doom/help)))
(after! doom-dashboard
  ;; Adjust banner padding for better vertical centering
  (setq +doom-dashboard-banner-padding '(8 . 4))
  ;; Override the banner widget to properly center the image
  (defun doom-dashboard-widget-banner ()
    (let ((point (point)))
      (if (and (display-graphic-p)
               (stringp fancy-splash-image)
               (file-readable-p fancy-splash-image))
          (let* ((image (create-image (fancy-splash-image-file)))
                 (img-width (car (image-size image t)))
                 ;; Add 2 extra spaces to shift right slightly
                 (line (make-string (max 1 (+ img-width 2)) ? )))
            ;; Insert a centered spacer line and display the image on it
            (insert (+doom-dashboard--center +doom-dashboard--width line) "\n")
            (add-text-properties
             point (1- (point)) `(display ,image rear-nonsticky (display)))
            (insert (make-string (or (cdr +doom-dashboard-banner-padding) 0)
                                 ?\n)))
        ;; Fallback to ASCII banner in terminal mode (optional)
        nil)))
  ;; Custom shortmenu with tighter spacing - use single newline instead of double
  (defun my/doom-dashboard-widget-shortmenu ()
    (insert "\n")
    (dolist (section +doom-dashboard-menu-sections)
      (cl-destructuring-bind (label &key icon action when face key) section
        (when (and (fboundp action)
                   (or (null when)
                       (eval when t)))
          (insert
           (+doom-dashboard--center
            (- +doom-dashboard--width 1)
            (let ((icon (if (stringp icon) icon (eval icon t))))
              (format (format "%s%%s%%-10s" (if icon "%3s\t" "%3s"))
                      (or icon "")
                      (with-temp-buffer
                        (insert-text-button
                         label
                         'action
                         `(lambda (_)
                            (call-interactively (or (command-remapping #',action)
                                                    #',action)))
                         'face (or face 'doom-dashboard-menu-title)
                         'follow-link t
                         'help-echo
                         (format "%s (%s)" label
                                 (propertize (symbol-name action) 'face 'doom-dashboard-menu-desc)))
                        (format "%-37s" (buffer-string)))
                      ;; Lookup command keys dynamically
                      (propertize
                       (or key
                           (when-let*
                               ((keymaps
                                 (delq
                                  nil (list (when (bound-and-true-p evil-local-mode)
                                              (evil-get-auxiliary-keymap +doom-dashboard-mode-map 'normal))
                                            +doom-dashboard-mode-map)))
                                (key
                                 (or (when keymaps
                                       (where-is-internal action keymaps t))
                                     (where-is-internal action nil t))))
                             (with-temp-buffer
                               (save-excursion (insert (key-description key)))
                               (while (re-search-forward "<\\([^>]+\\)>" nil t)
                                 (let ((str (match-string 1)))
                                   (replace-match
                                    (upcase (if (< (length str) 3)
                                                str
                                              (substring str 0 3))))))
                               (buffer-string)))
                           "")
                       'face 'doom-dashboard-menu-desc))))
           "\n")))))  ;; Use single \n instead of \n\n
  ;; Override dashboard widgets - remove loaded time, keep banner and menu
  (setq +doom-dashboard-functions
        '(doom-dashboard-widget-banner
          my/doom-dashboard-widget-shortmenu
          doom-dashboard-widget-footer))
  ;; Force reload dashboard to apply changes
  (when (get-buffer +doom-dashboard-name)
    (+doom-dashboard-reload t)))
#+end_src

* Vterm Configuration

The problem: Evil intercepts ESC globally before vterm can handle it.
The solution: Disable Evil's ESC keybinding in vterm buffers.
#+begin_src emacs-lisp
(after! vterm
  (add-hook 'vterm-mode-hook
    (lambda ()
      ;; ESC sends to terminal, not evil
      (evil-define-key 'insert vterm-mode-map
        (kbd "<escape>") 'vterm-send-escape)
      ;; Ctrl-c Ctrl-c enters normal mode
      (evil-define-key 'insert vterm-mode-map
        (kbd "C-c C-c") 'evil-normal-state))))
#+end_src

* Circe IRC Configuration

Configure Circe for automatic authentication with Libera Chat using SASL.
#+begin_src emacs-lisp
(setq circe-network-options
      '(("Libera Chat"
         :tls t
         :nick "Crocod1le"
         :sasl-username "Crocod1le"
         :sasl-password "Eight0011!!")))
#+end_src
To connect to Libera Chat with automatic authentication, simply run:
- =M-x circe RET Libera Chat RET=
This will connect you to Libera Chat and automatically authenticate your account.
<!-- Local Variables: -->
<!-- gptel-model: gpt-5-mini -->
<!-- gptel--backend-name: "Copilot" -->
<!-- gptel--bounds: nil -->
<!-- End: -->
