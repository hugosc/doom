#+TITLE: Doom Emacs Configuration
#+AUTHOR: Croc
#+PROPERTY: header-args :tangle yes :cache yes :results silent :padline no

* Table of Contents :TOC:

- [[#introduction][Introduction]]
- [[#basic-settings][Basic Settings]]
  - [[#directories][Directories]]
  - [[#emacs-server][Emacs Server]]
  - [[#auto-revert-mode][Auto-revert Mode]]
  - [[#user-information][User Information]]
  - [[#line-numbers][Line Numbers]]
  - [[#performance-tuning][Performance Tuning]]
- [[#visual-configuration][Visual Configuration]]
  - [[#fonts][Fonts]]
  - [[#theme-pywal-integration][Theme: Pywal Integration]]
  - [[#transparency-toggle-and-pywal-auto-reload][Transparency Toggle and Pywal Auto-Reload]]
- [[#org-roam-configuration][Org-Roam Configuration]]
  - [[#org-roam-ui][Org-Roam UI]]
  - [[#capture-templates][Capture Templates]]
  - [[#org-roam-dailies][Org-Roam Dailies]]
  - [[#helper-functions][Helper Functions]]
  - [[#keybindings][Keybindings]]
  - [[#buffer-navigation][Buffer Navigation]]
- [[#lecture-processing][Lecture Processing]]
- [[#file-navigation][File Navigation]]
  - [[#performance-fast-search-tools][Performance: Fast Search Tools]]
  - [[#yazi-integration-eeeel][Yazi Integration (eee.el)]]
  - [[#dired-configuration][Dired Configuration]]
- [[#ai-integration-gptel][AI Integration: GPTel]]
- [[#discord-presence][Discord Presence]]
- [[#org-agenda][Org Agenda]]
- [[#org-formatting][Org Formatting]]
- [[#org-inline-images][Org Inline Images]]
- [[#zen-mode-customization][Zen Mode Customization]]
- [[#dashboard-customization][Dashboard Customization]]
- [[#vterm-configuration][Vterm Configuration]]
- [[#circe-irc-configuration][Circe IRC Configuration]]

* Introduction

This is my Doom Emacs configuration, written in a literate style using org-mode.
The configuration is focused on academic work with org-roam for knowledge management
and GPTel for AI assistance via GitHub Copilot.

* Basic Settings

** Directories

Set the org-roam directory to my brain2 vault. This must be set before org-roam loads.
#+begin_src emacs-lisp
(setq org-roam-directory "~/Documents/brain2")
#+end_src
Set the general org-directory for agenda and other org features.
#+begin_src emacs-lisp
(setq org-directory "~/Documents/brain2/")
#+end_src

** Emacs Server

Start the emacs server to allow emacsclient connections (required for daemon mode and pywal hooks).
#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))
;; Also ensure server starts if running in daemon mode
(when (daemonp)
  (add-hook 'after-make-frame-functions
    (lambda (frame)
      (when (not (server-running-p))
        (server-start)))))
#+end_src

** Auto-revert Mode

Enable global auto-revert mode to automatically reload files when they change externally.
This is especially useful when working with external tools like OpenCode.
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(setq auto-revert-interval 20)   ; Check every 20 seconds (less aggressive)
(setq auto-revert-verbose nil)   ; Don't spam messages
#+end_src

** User Information

Configure user information for GPG, email clients, and file templates.
#+begin_src emacs-lisp
;; (setq user-full-name "John Doe"
;;       user-mail-address "john@doe.com")
#+end_src

** Line Numbers

Display line numbers in programming and text modes.
#+begin_src emacs-lisp
(setq display-line-numbers-type t)
#+end_src

** Performance Tuning

Optimize Emacs for better responsiveness and lower resource usage.
#+begin_src emacs-lisp
;; Increase garbage collection threshold for less frequent GC pauses
(setq gc-cons-threshold 100000000)  ; 100 MB (default is 800KB)
;; Increase amount of data Emacs reads from processes (better for LSP)
(setq read-process-output-max (* 1024 1024))  ; 1MB (default is 4KB)
;; Less aggressive auto-revert checks
(setq auto-revert-interval 20)       ; Check every 20s (default is 5s)
(setq auto-revert-check-vc-info nil) ; Don't check VC info (faster)
#+end_src

* Visual Configuration

** Fonts

Doom exposes five font variables for customization:
- =doom-font= -- the primary font to use
- =doom-variable-pitch-font= -- a non-monospace font (where applicable)
- =doom-big-font= -- used for =doom-big-font-mode=
- =doom-symbol-font= -- for symbols
- =doom-serif-font= -- for the =fixed-pitch-serif= face
Example configuration (commented out):
#+begin_src emacs-lisp
;; (setq doom-font (font-spec :family "Iosevka" :size 12 :weight 'semi-light)
;;       doom-variable-pitch-font (font-spec :family "Fira Sans" :size 13))
#+end_src

** Theme: Pywal Integration

I use =ewal= to integrate pywal colors with Doom themes, allowing my Emacs theme
to automatically match my wallpaper color scheme.
#+begin_src emacs-lisp
(use-package! ewal
  :init (setq ewal-use-built-in-always-p nil
              ewal-use-built-in-on-failure-p t
              ewal-built-in-palette "doom-one"))
(use-package! ewal-doom-themes
  :after ewal
  :config (progn
            (load-theme 'ewal-doom-one t)
            (enable-theme 'ewal-doom-one)))
#+end_src
Helper function to reload the pywal theme after changing wallpaper:
#+begin_src emacs-lisp
(defun reload-pywal-theme ()
  "Reload the pywal theme to reflect new colors."
  (interactive)
  (ewal-load-colors)
  (load-theme 'ewal-doom-one t)
  (message "Pywal theme reloaded!"))
#+end_src

** Transparency Toggle and Pywal Auto-Reload

Unified transparency system that syncs across kitty, st, and emacs.
Uses Super+Shift+P (via DWM) to toggle all windows simultaneously.
State is persisted in /tmp/transparency-state for new windows.
#+begin_src emacs-lisp
;; Read transparency state from file
(defun get-transparency-state ()
  "Read current transparency state from /tmp/transparency-state."
  (if (file-exists-p "/tmp/transparency-state")
      (with-temp-buffer
        (insert-file-contents "/tmp/transparency-state")
        (string-trim (buffer-string)))
    "transparent"))
;; Set initial transparency based on saved state
(let ((state (get-transparency-state)))
  (set-frame-parameter nil 'alpha-background 
                       (if (string= state "opaque") 100 85)))
;; Toggle function that syncs with system
(defun toggle-emacs-transparency ()
  "Toggle emacs frame transparency and sync with system state."
  (interactive)
  ;; Just call the system-wide toggle script which handles everything
  (start-process-shell-command 
   "toggle-transparency" nil "toggle-transparency"))
;; Watch for transparency state changes from external toggles
(when (functionp 'file-notify-add-watch)
  (let ((state-file "/tmp/transparency-state"))
    (file-notify-add-watch state-file '(change)
      (lambda (event)
        (when (eq (nth 1 event) 'changed)
          (let ((state (get-transparency-state)))
            (dolist (frame (frame-list))
              (set-frame-parameter frame 'alpha-background 
                                   (if (string= state "opaque") 100 85)))))))))
;; Watch for pywal color changes
(defun my/watch-pywal-colors ()
  "Set up file watcher for pywal colors.json to auto-reload theme."
  (when (functionp 'file-notify-add-watch)
    (let ((colors-file (expand-file-name "~/.cache/wal/colorscheme.json")))
      (when (file-exists-p colors-file)
        (file-notify-add-watch colors-file '(change)
          (lambda (event)
            (when (eq (nth 1 event) 'changed)
              (reload-pywal-theme))))))))
;; Auto-enable the color watcher when emacs starts
(my/watch-pywal-colors)
#+end_src

* Org-Roam Configuration

My org-roam setup is designed for academic work, using a Zettelkasten-style
knowledge management system with concepts, lectures, readings, and projects.

** Org-Roam UI

Configure org-roam-ui for visual graph navigation of my knowledge base.
#+begin_src emacs-lisp
(use-package! org-roam-ui
  :after org-roam
  :hook (org-roam-mode . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src

** Capture Templates

My capture templates support different types of content in my knowledge system:
- *Lectures* (=l=): Raw notes from lectures with post-processing checklist
- *Concepts* (=c=): Atomic concept nodes with definition, context, relations
- *Readings* (=rd=): Paper/book notes with citations
- *Recipes* (=r=): Recipe notes with ingredients and procedures
- *Assignments* (=a=): Coursework planning and tracking
- *Projects* (=p=): Personal project overviews
#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-v2-ack t)
  (setq org-roam-capture-templates
        '(("l" "Lecture quicknote" plain
           "%?\n* Post-Lecture Checklist\n- [ ] Extract definitions\n- [ ] Create/update concept node\n- [ ] Link readings\n- [ ] Mark processed"
           :if-new (file+head "academic/lectures/raw/%<%Y-%m-%d>-${slug}.org"
                              "#+TITLE: %<%Y-%m-%d> ${title} Lecture\n#+FILETAGS: :lecture:raw:\n")
           :unnarrowed t)
           ("c" "Concept node" plain
            "* Overview\n%?\n* Context\n* Relations\n* Applications\n* References"
            :if-new (file+head "concepts/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :concept:seed:\n")
            :unnarrowed t)
           ("rd" "Reading note" plain
            "* Summary\n%?\n* Key Claims\n* Methods\n* Critical Reflections\n* Links"
            :if-new (file+head "readings/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :reading:seed:\n:PROPERTIES:\n:ROAM_REFS: ${ref}\n:END:\n")
            :unnarrowed t)
           ("r" "Recipe" plain
            "* Ingredients\n\n- \n\n* Prep\n\n- \n\n* Procedure\n\n1. \n\n* Notes\n\n%?"
            :if-new (file+head "recipes/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :recipe:\n")
            :unnarrowed t)
          ("a" "Assignment plan" plain
           "* Brief\n%?\n* Requirements\n* Sources\n* Outline\n* Timeline\n* Status"
           :if-new (file+head "assignments/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :assignment:active:\n")
           :unnarrowed t)
           ("p" "Project node" plain
            "* Overview\n%?\n* Goals\n* Links\n* Decisions\n* TODO\n* Resources"
            :if-new (file+head "projects/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :project:active:\n")
            :unnarrowed t)))
  
  ;; Org-Roam Dailies Configuration
  (setq org-roam-dailies-directory "daily/")
  (setq org-roam-dailies-capture-templates
        '(("d" "Daily" entry
           "* <%<%Y-%m-%d %a %H:%M>>\n%?"
           :target (file+head "%<%Y-%m-%d>.org"
                              "#+TITLE: %<%B %d, %Y>\n#+FILETAGS: :daily:\n")))))
#+end_src

** Org-Roam Dailies

The dailies configuration is now integrated into the main org-roam configuration block above.

** Helper Functions

*** Promote Heading to Concept

This function extracts a heading from a lecture or inbox note and promotes it
to a standalone concept node. The heading's contents are copied into the new
concept file under the =* Overview= section, and a reference link to the original
heading is added to the concept's =* References= section. The original heading
is preserved (not deleted).
#+begin_src emacs-lisp
  (defun my/org-roam-promote-heading-to-concept ()
    "Promote current heading into a new concept node.
This:
- Creates `concepts/<slug>.org` (if missing) with a scaffold that uses '* Overview'.
- Copies the current heading's subtree (content below the heading line) into
  the new file under '* Overview' (appends).
- Transfers the original heading's ID to the new file (if it exists), so existing
  links to that heading automatically resolve to the new concept file.
- Removes the ID from the original heading to avoid duplicates.
- Inserts a link to the new concept in the original file's '* Relations' section as a bullet point.
It does NOT delete or replace the original heading." 
    (interactive)
    (unless (org-at-heading-p)
      (user-error "Not at a heading"))
    (let* ((title (nth 4 (org-heading-components)))
           (node (org-roam-node-create :title title))
           (slug (org-roam-node-slug node))
           (file (expand-file-name (format "concepts/%s.org" slug) org-roam-directory))
           ;; original subtree bounds
           (orig-beg (save-excursion (org-back-to-heading t) (point)))
           (orig-end (save-excursion (org-end-of-subtree t t)))
           ;; body = text after the heading line up to end of subtree
           (body (save-restriction
                   (widen)
                   (when (> orig-end orig-beg)
                     (save-excursion
                       (goto-char orig-beg)
                       (forward-line 1)
                       ;; Skip properties drawer if present
                       (when (looking-at "^[ \t]*:PROPERTIES:")
                         (when (re-search-forward "^[ \t]*:END:" orig-end t)
                           (forward-line 1)))
                       ;; Skip any blank lines after properties
                       (while (and (< (point) orig-end) (looking-at-p "^\\s-*$"))
                         (forward-line 1))
                       ;; Extract the actual content
                       (let ((content-start (point)))
                         (when (< content-start orig-end)
                           (string-trim (buffer-substring-no-properties content-start orig-end)))))))))
      ;; Ensure original heading has an ID so we can link to it later if needed
      (let ((orig-id (save-excursion
                       (org-back-to-heading t)
                       (or (org-entry-get nil "ID")
                           (org-id-get-create)))))
        ;; Create scaffold if file doesn't exist
        (unless (file-exists-p file)
          (with-temp-file file
            (insert ":PROPERTIES:\n:END:\n#+TITLE: " title "\n#+FILETAGS: :concept:seed:\n\n* Overview\n\n* Context\n* Relations\n* Applications\n* References\n")))
        ;; Transfer or create ID: use heading's existing ID if present, otherwise generate new one
        (let ((new-id (if orig-id
                          ;; Use the original heading's ID for the new file
                          (progn
                            (with-current-buffer (find-file-noselect file)
                              (goto-char (point-min))
                              (when (re-search-forward "^:PROPERTIES:" nil t)
                                (forward-line 1)
                                (insert (format ":ID: %s\n" orig-id)))
                              (save-buffer))
                            ;; Delete entire properties drawer from original heading
                            (save-excursion
                              (org-back-to-heading t)
                              (when (re-search-forward "^[ \t]*:PROPERTIES:" (save-excursion (outline-next-heading) (point)) t)
                                (let ((beg (line-beginning-position)))
                                  (when (re-search-forward "^[ \t]*:END:" (save-excursion (outline-next-heading) (point)) t)
                                    (delete-region beg (1+ (line-end-position)))))))
                            (save-buffer)
                            orig-id)
                        ;; No existing ID, generate a new one for the concept file
                        (let ((generated-id (org-id-new)))
                          (with-current-buffer (find-file-noselect file)
                            (goto-char (point-min))
                            (when (re-search-forward "^:PROPERTIES:" nil t)
                              (forward-line 1)
                              (insert (format ":ID: %s\n" generated-id)))
                            (save-buffer))
                          generated-id))))
          ;; Insert body into Overview if present
          (when (and body (not (string-empty-p (string-trim body))))
            (with-current-buffer (find-file-noselect file)
              (save-excursion
                (goto-char (point-min))
                (when (re-search-forward "^\\* Overview\\s-*$" nil t)
                  (forward-line 1)
                  ;; Clean up: remove any existing blank lines after Overview heading
                  (while (looking-at-p "^\\s-*$")
                    (delete-region (line-beginning-position) (1+ (line-end-position))))
                  ;; Insert the trimmed body content
                  (insert (string-trim body) "\n")
                  (save-buffer)))))
          ;; Insert a link to the NEW concept into the original file's *Relations section
          (save-excursion
            (goto-char (point-min))
            (if (re-search-forward "^\\* Relations\\s-*$" nil t)
                ;; Found Relations section, insert link
                (progn
                  (forward-line 1)
                  (insert (format "- [[id:%s][%s]]\n" new-id title))
                  (save-buffer))
              ;; No Relations section, create one at end of file
              (goto-char (point-max))
              (unless (bolp) (insert "\n"))
              (insert (format "* Relations\n- [[id:%s][%s]]\n" new-id title))
              (save-buffer)))
           (message "Promoted '%s' â†’ %s (id:%s) and inserted link in original file" title file new-id)))))
#+end_src

*** Insert File Link

Insert a link to an external file (useful for linking to project files, GitHub repos, etc).
#+begin_src emacs-lisp
  (defun my/insert-file-link (path)
    "Insert an org file link to PATH with basename as description."
    (interactive "fFile: ")
    (insert (format "[[file:%s][%s]]" (abbreviate-file-name path) (file-name-base path))))
#+end_src

*** Add Heading ID

Add a UUID to a heading with a human-readable alias for easier referencing.
#+begin_src emacs-lisp
  (defun my/add-heading-id ()
    "Add org-id UUID to heading with filename-heading alias for org-roam."
    (interactive)
    (org-back-to-heading t)
    (let* ((filename (file-name-base (buffer-file-name)))
           (title (nth 4 (org-heading-components)))
           (alias (format "%s - %s" filename title))
           (id (org-id-get-create)))
      (org-set-property "ROAM_ALIASES" (format "\"%s\"" alias))
      (message "Added ID with alias: %s" alias)))
#+end_src

*** Insert Heading Link

Interactive function to pick an org file and heading, then insert a link with proper ID.
#+begin_src emacs-lisp
  (defun my/insert-heading-link ()
    "Pick an org file recursively, then link to a heading with org-id."
    (interactive)
    (let* ((current-buf (current-buffer))
           (brain2-dir (expand-file-name "~/Documents/brain2/"))
           (default-directory brain2-dir)
           ;; Get all org files recursively
           (org-files (directory-files-recursively brain2-dir "\\.org$"))
           ;; Make paths relative for cleaner display
           (file-choices (mapcar (lambda (f) (file-relative-name f brain2-dir)) org-files))
           (file-rel (completing-read "Org file: " file-choices nil t))
           (file (expand-file-name file-rel brain2-dir))
           (filename (file-name-base file)))
      (unless (file-exists-p file)
        (user-error "File not found: %s" file))
      ;; List headings in that file
      (with-current-buffer (find-file-noselect file)
        (let* ((headings (org-map-entries (lambda () (nth 4 (org-heading-components))) nil 'file))
               (heading (completing-read "Heading: " headings)))
          ;; Find the heading and get/create its ID
          (goto-char (point-min))
          (unless (search-forward heading nil t)
            (user-error "Heading not found: %s" heading))
          (org-back-to-heading t)
          (let* ((id (org-id-get-create))
                 (alias (format "%s - %s" filename heading))
                 (link (format "[[id:%s][%s]]" id heading)))
            ;; Ensure alias is set
            (unless (org-entry-get nil "ROAM_ALIASES")
              (org-set-property "ROAM_ALIASES" (format "\"%s\"" alias)))
            ;; Switch back to original buffer and insert link
            (with-current-buffer current-buf
              (insert link)
              (message "Inserted link: %s" link)))))))
#+end_src

** Keybindings

All org-roam related keybindings are under the =SPC n= prefix.
#+begin_src emacs-lisp
  (map! :leader
        :desc "Promote heading to concept" "n P" #'my/org-roam-promote-heading-to-concept
        :desc "Insert file link" "n f" #'my/insert-file-link
        :desc "Add heading ID" "n i" #'my/add-heading-id
        :desc "Insert heading link" "n h" #'my/insert-heading-link
        :desc "Find/create node" "n n" #'org-roam-node-find
        :desc "Insert node link" "n l" #'org-roam-node-insert
        :desc "Toggle backlinks" "n b" #'org-roam-buffer-toggle
        :desc "Open graph UI" "n g" #'org-roam-ui-open
        :desc "Capture new node" "n c" #'org-roam-capture)
#+end_src

** Buffer Navigation

Keybindings for cycling through buffers with Alt+Shift+H/L.
We need to unbind evil-org-mode's bindings which override the global ones.
#+begin_src emacs-lisp
;; Unbind evil-org-mode's M-H and M-L bindings
(after! evil-org
  (map! :map evil-org-mode-map
        :nvi "M-H" nil
        :nvi "M-L" nil))
;; Now set our buffer navigation bindings
(map! :nvi "M-H" #'previous-buffer
      :nvi "M-L" #'next-buffer)
#+end_src

* Lecture Processing

Helper function to mark a lecture as processed and move it from =raw/= to =processed/=.
#+begin_src emacs-lisp
(defun my/mark-lecture-processed ()
  "Mark current lecture note as processed and move to processed directory."
  (interactive)
  (let* ((file (buffer-file-name))
         (rel (file-relative-name file org-roam-directory)))
    (unless (string-match-p "academic/lectures/raw/" rel)
      (user-error "Not in raw lectures directory"))
    (save-excursion
      (goto-char (point-min))
      (unless (re-search-forward "POST-LECTURE CHECKLIST" nil t)
        (goto-char (point-max)))
      (save-buffer)
      (org-set-property "PROCESSED" (format-time-string "%Y-%m-%d")))
    (let* ((dest (expand-file-name (concat "academic/lectures/processed/" (file-name-nondirectory file)) org-roam-directory)))
      (rename-file file dest 1)
      (find-file dest)
      (message "Lecture processed & moved."))))
(map! :leader :desc "Process lecture" "n L" #'my/mark-lecture-processed)
#+end_src

* File Navigation

Use =consult-fd= for live, telescope-like file finding without caching.
#+begin_src emacs-lisp
(map! :leader :desc "Find file (live)" "SPC" #'consult-fd)
#+end_src

** Performance: Fast Search Tools

Configure Emacs to use modern fast tools (fd, ripgrep) for all search operations.
#+begin_src emacs-lisp
;; Use fd instead of find for projectile
(after! projectile
  (when (executable-find "fd")
    (setq projectile-git-command "fd . -0 --type f --color=never"
          projectile-generic-command "fd . -0 --type f --color=never"
          projectile-indexing-method 'alien
          projectile-enable-caching nil)))  ; No cache needed with fd
;; Use ripgrep for project search
(after! counsel
  (when (executable-find "rg")
    (setq counsel-rg-base-command "rg --no-heading --line-number --color never %s .")))
;; Configure consult to use ripgrep and fd
(after! consult
  (when (executable-find "rg")
    (setq consult-ripgrep-args "rg --null --line-buffered --color=never --max-columns=1000 --path-separator / --smart-case --no-heading --with-filename --line-number --search-zip"))
  (when (executable-find "fd")
    (setq consult-fd-args "fd --color=never --full-path --hidden --exclude .git")))
;; Use ripgrep for Doom's default search
(after! vertico
  (when (executable-find "rg")
    (setq +default-want-RET-continue-p nil)))
#+end_src

** Yazi Integration (eee.el)

Launch yazi file manager in external terminal with Emacs integration.
#+begin_src emacs-lisp
(use-package! eee
  :config
  ;; Use kitty terminal for yazi and other TUI tools
  (setq ee-terminal-command "kitty")
  
  ;; Keybindings for yazi and other TUI tools
  (map! :leader
        :desc "Yazi (current dir)" "f y" #'ee-yazi
        :desc "Yazi (project)" "f Y" #'ee-yazi-project
        :desc "Ripgrep search" "s g" #'ee-rg
         :desc "Lazygit" "g z" #'ee-lazygit))
#+end_src

** Dired Configuration

Improve dired usability with better clipboard commands.
- Press ~y Y~ in dired to copy file itself to clipboard (for pasting into apps like Discord)
#+begin_src emacs-lisp
(after! dired
  (defun my/dired-copy-file-to-clipboard ()
    "Copy the file at point to system clipboard for pasting into applications."
    (interactive)
    (let ((file (dired-get-filename)))
      (if (file-directory-p file)
          (message "Cannot copy directory to clipboard")
        (let* ((mime-type (string-trim
                           (shell-command-to-string
                            (format "file --mime-type -b %s" (shell-quote-argument file)))))
               (cmd (format "xclip -selection clipboard -t %s -i %s"
                            mime-type
                            (shell-quote-argument file))))
          (call-process-shell-command cmd nil 0)
          (message "Copied file to clipboard: %s" (file-name-nondirectory file))))))
  
  (map! :map dired-mode-map
        :n "y Y" #'my/dired-copy-file-to-clipboard))
#+end_src

* AI Integration: GPTel

GPTel provides AI assistance directly in Emacs.
#+begin_src emacs-lisp
(use-package! gptel
  :config
  (setq gptel-model 'gpt-5-mini
        gptel-backend (gptel-make-gh-copilot "Copilot")
        gptel-default-mode 'org-mode)
  
  ;; Preset for org-roam PKM work with psychology studies
  (gptel-make-preset 'brain2beta
    :description "Org-roam PKM assistant for psychology studies"
    :backend "Copilot"
    :model 'gpt-4.1
    :system "You are a large language model living in my DOOM Emacs and a helpful assistant. We are currently operating within my org-roam based PKM, which I am learning to use to manage my life studying psychology and my interests. Respond concisely."
    :stream t
    :temperature 1.0
    :include-reasoning t
    :use-context 'system))
#+end_src
To use GPTel:
- =M-x gptel= -- Open a chat buffer
- =M-x gptel-menu= -- Select model/backend
- =C-u C-c RET= -- Open options menu to switch presets
- In org-mode, select region and send to gptel for processing

* Discord Presence

Show your Emacs activity on Discord using emacs-rpc.
Lazy-loaded to avoid startup overhead.
#+begin_src emacs-lisp
(use-package! presence
  :defer 5  ; Load 5 seconds after startup (lazy-load for performance)
  :commands (presence-mode)
  :init
  ;; Don't auto-enable, let it load lazily
  (run-with-idle-timer 5 nil #'presence-mode)
  :config
  ;; Use custom Discord application
  (setq presence-client-id "1443438985878962228")
  ;; Use asset keys directly (not URLs) for our custom Discord app
  (setq presence-icon-base nil)
  ;; Override to return just the asset key
  (defun presence--resolve-icon-base (icon)
    "Return just the icon asset key for Discord."
    icon)
  ;; Use custom icon from our Discord app
  (setq presence-editor-icon "emacs-icon")
  ;; Keep editor as main icon, mode as small icon
  (setq presence-use-major-mode-as-main-icon nil)
  ;; Show the small icon (mode icon)
  (setq presence-show-small-icon t)
  ;; Add extra mode icon mappings
  (setq presence-mode-icon-alist
        (append '((magit-status-mode . "git")
                  (magit-log-mode . "git")
                  (magit-diff-mode . "git")
                  (magit-revision-mode . "git")
                  (conf-toml-mode . "toml"))
                presence-mode-icon-alist))
  ;; Hide line numbers from status
  (setq presence-display-line-numbers nil)
  ;; Custom format: show project name + file instead of just buffer name
  (defun my/presence-buffer-details ()
    (let ((project (projectile-project-name))
          (file (buffer-name)))
      (if (and project (not (string= project "-")))
          (format "In %s: %s" project file)
        (format "Editing %s" file))))
  (setq presence-buffer-details-format-function #'my/presence-buffer-details))
#+end_src

* Org Agenda

Configure org-agenda to search the entire brain2 directory for TODOs and scheduled items.
#+begin_src emacs-lisp
(setq org-agenda-start-with-log-mode t)
(after! org
  (setq org-agenda-files '("~/Documents/brain2/")
        org-log-done 'time
        org-hide-emphasis-markers t)
  ;; Fallback: ensure emphasis markers are hidden when org-mode starts
  (add-hook 'org-mode-hook (lambda () (setq org-hide-emphasis-markers t))))
  ;; Config for custom agenda view
(setq org-agenda-custom-commands
 '(("p" "Planning"
             ((tags-todo "+@planning"
                         ((org-agenda-overriding-header "Planning Tasks")))
              (tags-todo "-{.*}"
                         ((org-agenda-overriding-header "Untagged Tasks")))
              (todo ".*" ((org-agenda-files '("~/Documents/brain2/inbox.org"))
                          (org-agenda-overriding-header "Unprocessed Inbox Items")))))
        ("d" "Daily Agenda"
         ((agenda "" ((org-agenda-span 'day)
                      (org-deadline-warning-days 7)))
          (tags-todo "+PRIORITY=\"A\""
                     ((org-agenda-overriding-header "High Priority Tasks")))))
        ("w" "Weekly Review"
         ((agenda ""
                  ((org-agenda-overriding-header "Completed Tasks")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo 'done))
                   (org-agenda-span 'week)))
          (agenda ""
                  ((org-agenda-overriding-header "Unfinished Scheduled Tasks")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-span 'week))))))
      )
#+end_src

* Org Formatting

Simple, clean formatting for org files:
- Heading, then immediately PROPERTIES (if any)
- Then immediately SCHEDULED/DEADLINE (if any)
- Then ONE blank line before body content (if any)
- ONE blank line before next heading at same/higher level
#+begin_src emacs-lisp
(after! org
  ;; Set up org-capture templates for inbox
  (setq org-capture-templates
        '(("i" "Inbox TODO" entry
           (file+olp "~/Documents/brain2/inbox.org" "Global")
           "** TODO %?\n"
           :empty-lines 1)
          ("w" "Weekly TODO" entry
           (file+olp "~/Documents/brain2/inbox.org" "This Week")
           "** TODO %?\n"
           :empty-lines 1)))
  
  (defun my/org-format-buffer ()
    "Format org buffer with consistent, clean spacing matching example.org style."
    (interactive)
    (save-excursion
      ;; First, remove ALL blank lines in entire buffer
      (goto-char (point-min))
      (while (re-search-forward "\n\n+" nil t)
        (replace-match "\n"))
      
      ;; Add blank line after title/filetags section
      (goto-char (point-min))
      (when (re-search-forward "^#\\+\\(TITLE\\|FILETAGS\\):" nil t)
        (forward-line 1)
        (while (looking-at "^#\\+")
          (forward-line 1))
        (when (looking-at "^:PROPERTIES:")
          (re-search-forward "^:END:" nil t)
          (forward-line 1))
        (when (looking-at "^\\*")
          (insert "\n")))
      
      ;; Process all headings
      (goto-char (point-min))
      (while (re-search-forward "^\\(\\*+\\) " nil t)
        (forward-line 1)
        (when (looking-at "^[ \t]*:PROPERTIES:")
          (re-search-forward "^[ \t]*:END:" nil t)
          (forward-line 1))
        (while (looking-at "^[ \t]*\\(SCHEDULED:\\|DEADLINE:\\|CLOSED:\\)")
          (forward-line 1))
        (when (looking-at "^[ \t]*:LOGBOOK:")
          (re-search-forward "^[ \t]*:END:" nil t)
          (forward-line 1))
        (let ((content-start (point)))
          (cond
           ((eobp)
            (insert "\n"))
           ((looking-at "^\\*")
            (insert "\n"))
           (t
            (goto-char content-start)
            (insert "\n")
            (if (re-search-forward "^\\*" nil t)
                (progn
                  (beginning-of-line)
                  (insert "\n")
                  (beginning-of-line))
              (goto-char (point-max))
              (unless (bolp)
                (insert "\n")))))))
      
      ;; Add blank lines before attachment links (but not after captions)
      (goto-char (point-min))
      (while (re-search-forward "^\\[\\[attachment:" nil t)
        (beginning-of-line)
        ;; Check if previous line is not blank and not an italic caption
        (unless (or (bobp)
                    (save-excursion
                      (forward-line -1)
                      (or (looking-at "^[ \t]*$")
                          (looking-at "^/"))))
          (insert "\n"))
        (forward-line 1))
      
      ;; Add blank lines after italic captions (when followed by attachment or body text)
      (goto-char (point-min))
      (while (re-search-forward "^/.+/$" nil t)
        (forward-line 1)
        ;; Add blank line if next line exists and is not blank and not a heading
        (unless (or (eobp)
                    (looking-at "^[ \t]*$")
                    (looking-at "^\\*"))
          (insert "\n")))
      
      ;; Clean up trailing blank lines
      (goto-char (point-max))
      (while (and (> (point) 1)
                  (eq (char-before) ?\n)
                  (eq (char-before (1- (point))) ?\n))
        (delete-char -1))))
   
   ;; Enable auto-format on save
    (add-hook 'org-mode-hook
      (lambda ()
        (add-hook 'before-save-hook #'my/org-format-buffer nil t)))
   )
#+end_src

* Org Inline Images

Optimize inline image display performance by limiting the display width.
This dramatically reduces lag when scrolling past large screenshots (e.g., 1920x1080).
Images are displayed at max 800px width while the full-resolution files remain unchanged.
To view the full resolution, open the image externally with =RET= on the link.
#+begin_src emacs-lisp
(after! org
  ;; Display images at max 800px width instead of full resolution
  ;; This reduces rendering overhead for large screenshots
  (setq org-image-actual-width 600)
  (setq org-image-align 'center))
#+end_src

* Zen Mode Customization

Configure zen mode (writeroom-mode) with smaller font, wider margins, no line numbers, and hidden org stars.
#+begin_src emacs-lisp
(setq +zen-text-scale 1)           ;; Font size scale (1 = one size larger)
(setq writeroom-width 70)          ;; Column width (narrower = wider margins)
;; Configure org-modern to always be on for org-mode
(after! org-modern
  (setq org-modern-hide-stars 'leading)
  ;; Enable org-modern globally
  (add-hook 'org-mode-hook #'org-modern-mode))
;; Zen mode hook - hide line numbers, adjust org-modern star display
(add-hook 'writeroom-mode-hook
  (lambda ()
    (if writeroom-mode
        (progn
          (display-line-numbers-mode -1)
          (when (derived-mode-p 'org-mode)
            (setq-local org-modern-hide-stars t))
          (text-scale-set 1))
      (progn
        ;; Restore when exiting zen mode
        (display-line-numbers-mode 1)
        (when (derived-mode-p 'org-mode)
          (setq-local org-modern-hide-stars 'leading))))))
#+end_src

* Dashboard Customization

#+begin_src emacs-lisp
;; Use custom emacs logo image as the dashboard banner with minimal menu.
;; Set BEFORE doom-dashboard loads - use pre-scaled high-quality XPM
(setq +doom-dashboard-banner-file "default.xpm"
      +doom-dashboard-banner-dir (expand-file-name "~/.config/emacs/modules/ui/doom-dashboard/banners/"))
(setq +doom-dashboard-menu-sections
      '(("Open project"
         :icon (nerd-icons-sucicon "nf-custom-folder_git" :face 'doom-dashboard-menu-title :height 1.3)
         :action projectile-switch-project)
        ("Open documentation"
         :icon (nerd-icons-faicon "nf-fa-book_skull" :face 'doom-dashboard-menu-title :height 1.3)
         :action doom/help)))
(after! doom-dashboard
  ;; Adjust banner padding for better vertical centering
  (setq +doom-dashboard-banner-padding '(8 . 4))
  ;; Override the banner widget to properly center the image
  (defun doom-dashboard-widget-banner ()
    (let ((point (point)))
      (if (and (display-graphic-p)
               (stringp fancy-splash-image)
               (file-readable-p fancy-splash-image))
          (let* ((image (create-image (fancy-splash-image-file)))
                 (img-width (car (image-size image t)))
                 ;; Add 2 extra spaces to shift right slightly
                 (line (make-string (max 1 (+ img-width 2)) ? )))
            ;; Insert a centered spacer line and display the image on it
            (insert (+doom-dashboard--center +doom-dashboard--width line) "\n")
            (add-text-properties
             point (1- (point)) `(display ,image rear-nonsticky (display)))
            (insert (make-string (or (cdr +doom-dashboard-banner-padding) 0)
                                 ?\n)))
        ;; Fallback to ASCII banner in terminal mode (optional)
        nil)))
  ;; Custom shortmenu with tighter spacing - use single newline instead of double
  (defun my/doom-dashboard-widget-shortmenu ()
    (insert "\n")
    (dolist (section +doom-dashboard-menu-sections)
      (cl-destructuring-bind (label &key icon action when face key) section
        (when (and (fboundp action)
                   (or (null when)
                       (eval when t)))
          (insert
           (+doom-dashboard--center
            (- +doom-dashboard--width 1)
            (let ((icon (if (stringp icon) icon (eval icon t))))
              (format (format "%s%%s%%-10s" (if icon "%3s\t" "%3s"))
                      (or icon "")
                      (with-temp-buffer
                        (insert-text-button
                         label
                         'action
                         `(lambda (_)
                            (call-interactively (or (command-remapping #',action)
                                                    #',action)))
                         'face (or face 'doom-dashboard-menu-title)
                         'follow-link t
                         'help-echo
                         (format "%s (%s)" label
                                 (propertize (symbol-name action) 'face 'doom-dashboard-menu-desc)))
                        (format "%-37s" (buffer-string)))
                      ;; Lookup command keys dynamically
                      (propertize
                       (or key
                           (when-let*
                               ((keymaps
                                 (delq
                                  nil (list (when (bound-and-true-p evil-local-mode)
                                              (evil-get-auxiliary-keymap +doom-dashboard-mode-map 'normal))
                                            +doom-dashboard-mode-map)))
                                (key
                                 (or (when keymaps
                                       (where-is-internal action keymaps t))
                                     (where-is-internal action nil t))))
                             (with-temp-buffer
                               (save-excursion (insert (key-description key)))
                               (while (re-search-forward "<\\([^>]+\\)>" nil t)
                                 (let ((str (match-string 1)))
                                   (replace-match
                                    (upcase (if (< (length str) 3)
                                                str
                                              (substring str 0 3))))))
                               (buffer-string)))
                           "")
                       'face 'doom-dashboard-menu-desc))))
           "\n")))))  ;; Use single \n instead of \n\n
  ;; Override dashboard widgets - remove loaded time, keep banner and menu
  (setq +doom-dashboard-functions
        '(doom-dashboard-widget-banner
          my/doom-dashboard-widget-shortmenu
          doom-dashboard-widget-footer))
  ;; Force reload dashboard to apply changes
  (when (get-buffer +doom-dashboard-name)
    (+doom-dashboard-reload t)))
#+end_src

* Vterm Configuration

The problem: Evil intercepts ESC globally before vterm can handle it.
The solution: Disable Evil's ESC keybinding in vterm buffers.
#+begin_src emacs-lisp
(after! vterm
  (add-hook 'vterm-mode-hook
    (lambda ()
      ;; ESC sends to terminal, not evil
      (evil-define-key 'insert vterm-mode-map
        (kbd "<escape>") 'vterm-send-escape)
      ;; Ctrl-c Ctrl-c enters normal mode
      (evil-define-key 'insert vterm-mode-map
        (kbd "C-c C-c") 'evil-normal-state))))
#+end_src

* Circe IRC Configuration

Configure Circe for automatic authentication with Libera Chat using SASL.
#+begin_src emacs-lisp
(setq circe-network-options
      '(("Libera Chat"
         :tls t
         :nick "Crocod1le"
         :sasl-username "Crocod1le"
         :sasl-password "Eight0011!!")))
#+end_src
To connect to Libera Chat with automatic authentication, simply run:
- =M-x circe RET Libera Chat RET=
This will connect you to Libera Chat and automatically authenticate your account.
<!-- Local Variables: -->
<!-- gptel-model: gpt-5-mini -->
<!-- gptel--backend-name: "Copilot" -->
<!-- gptel--bounds: nil -->
<!-- End: -->
