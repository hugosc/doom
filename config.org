#+TITLE: Doom Emacs Configuration
#+AUTHOR: Croc
#+PROPERTY: header-args :tangle yes :cache yes :results silent :padline no

* Table of Contents :TOC:

- [[#introduction][Introduction]]
- [[#basic-settings][Basic Settings]]
  - [[#directories][Directories]]
  - [[#emacs-server][Emacs Server]]
  - [[#auto-revert-mode][Auto-revert Mode]]
  - [[#user-information][User Information]]
  - [[#line-numbers][Line Numbers]]
  - [[#performance-tuning][Performance Tuning]]
- [[#visual-configuration][Visual Configuration]]
  - [[#fonts][Fonts]]
  - [[#theme-pywal-integration][Theme: Pywal Integration]]
  - [[#transparency-toggle-and-pywal-auto-reload][Transparency Toggle and Pywal Auto-Reload]]
- [[#org-roam-configuration][Org-Roam Configuration]]
  - [[#org-roam-ui][Org-Roam UI]]
  - [[#capture-templates][Capture Templates]]
  - [[#helper-functions][Helper Functions]]
  - [[#keybindings][Keybindings]]
- [[#lecture-processing][Lecture Processing]]
- [[#file-navigation][File Navigation]]
  - [[#performance-fast-search-tools][Performance: Fast Search Tools]]
  - [[#yazi-integration-eeeel][Yazi Integration (eee.el)]]
- [[#ai-integration-gptel][AI Integration: GPTel]]
- [[#discord-presence][Discord Presence]]
- [[#org-agenda][Org Agenda]]
- [[#org-formatting][Org Formatting]]
- [[#zen-mode-customization][Zen Mode Customization]]
- [[#dashboard-customization][Dashboard Customization]]
- [[#vterm-configuration][Vterm Configuration]]

* Introduction

This is my Doom Emacs configuration, written in a literate style using org-mode.
The configuration is focused on academic work with org-roam for knowledge management
and GPTel for AI assistance via GitHub Copilot.

* Basic Settings

** Directories

Set the org-roam directory to my brain2 vault. This must be set before org-roam loads.

#+begin_src emacs-lisp
(setq org-roam-directory "~/Documents/brain2")
#+end_src

Set the general org-directory for agenda and other org features.

#+begin_src emacs-lisp
(setq org-directory "~/Documents/brain2/")
#+end_src

** Emacs Server

Start the emacs server to allow emacsclient connections (required for daemon mode and pywal hooks).

#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))

;; Also ensure server starts if running in daemon mode
(when (daemonp)
  (add-hook 'after-make-frame-functions
    (lambda (frame)
      (when (not (server-running-p))
        (server-start)))))
#+end_src

** Auto-revert Mode

Enable global auto-revert mode to automatically reload files when they change externally.
This is especially useful when working with external tools like OpenCode.

#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(setq auto-revert-interval 20)   ; Check every 20 seconds (less aggressive)
(setq auto-revert-verbose nil)   ; Don't spam messages
#+end_src

** User Information

Configure user information for GPG, email clients, and file templates.

#+begin_src emacs-lisp
;; (setq user-full-name "John Doe"
;;       user-mail-address "john@doe.com")
#+end_src

** Line Numbers

Display line numbers in programming and text modes.

#+begin_src emacs-lisp
(setq display-line-numbers-type t)
#+end_src

** Performance Tuning

Optimize Emacs for better responsiveness and lower resource usage.

#+begin_src emacs-lisp
;; Increase garbage collection threshold for less frequent GC pauses
(setq gc-cons-threshold 100000000)  ; 100 MB (default is 800KB)

;; Increase amount of data Emacs reads from processes (better for LSP)
(setq read-process-output-max (* 1024 1024))  ; 1MB (default is 4KB)

;; Less aggressive auto-revert checks
(setq auto-revert-interval 20)       ; Check every 20s (default is 5s)
(setq auto-revert-check-vc-info nil) ; Don't check VC info (faster)
#+end_src

* Visual Configuration

** Fonts

Doom exposes five font variables for customization:
- =doom-font= -- the primary font to use
- =doom-variable-pitch-font= -- a non-monospace font (where applicable)
- =doom-big-font= -- used for =doom-big-font-mode=
- =doom-symbol-font= -- for symbols
- =doom-serif-font= -- for the =fixed-pitch-serif= face

Example configuration (commented out):

#+begin_src emacs-lisp
;; (setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'semi-light)
;;       doom-variable-pitch-font (font-spec :family "Fira Sans" :size 13))
#+end_src

** Theme: Pywal Integration

I use =ewal= to integrate pywal colors with Doom themes, allowing my Emacs theme
to automatically match my wallpaper color scheme.

#+begin_src emacs-lisp
(use-package! ewal
  :init (setq ewal-use-built-in-always-p nil
              ewal-use-built-in-on-failure-p t
              ewal-built-in-palette "doom-one"))

(use-package! ewal-doom-themes
  :after ewal
  :config (progn
            (load-theme 'ewal-doom-one t)
            (enable-theme 'ewal-doom-one)))
#+end_src

Helper function to reload the pywal theme after changing wallpaper:

#+begin_src emacs-lisp
(defun reload-pywal-theme ()
  "Reload the pywal theme to reflect new colors."
  (interactive)
  (ewal-load-colors)
  (load-theme 'ewal-doom-one t)
  (message "Pywal theme reloaded!"))
#+end_src

** Transparency Toggle and Pywal Auto-Reload

Unified transparency system that syncs across kitty, st, and emacs.
Uses Super+Shift+P (via DWM) to toggle all windows simultaneously.
State is persisted in /tmp/transparency-state for new windows.

#+begin_src emacs-lisp
;; Read transparency state from file
(defun get-transparency-state ()
  "Read current transparency state from /tmp/transparency-state."
  (if (file-exists-p "/tmp/transparency-state")
      (with-temp-buffer
        (insert-file-contents "/tmp/transparency-state")
        (string-trim (buffer-string)))
    "transparent"))

;; Set initial transparency based on saved state
(let ((state (get-transparency-state)))
  (set-frame-parameter nil 'alpha-background 
                       (if (string= state "opaque") 100 85)))

;; Toggle function that syncs with system
(defun toggle-emacs-transparency ()
  "Toggle emacs frame transparency and sync with system state."
  (interactive)
  ;; Just call the system-wide toggle script which handles everything
  (start-process-shell-command 
   "toggle-transparency" nil "toggle-transparency"))

;; Watch for transparency state changes from external toggles
(when (functionp 'file-notify-add-watch)
  (let ((state-file "/tmp/transparency-state"))
    (file-notify-add-watch state-file '(change)
      (lambda (event)
        (when (eq (nth 1 event) 'changed)
          (let ((state (get-transparency-state)))
            (dolist (frame (frame-list))
              (set-frame-parameter frame 'alpha-background 
                                   (if (string= state "opaque") 100 85)))))))))

;; Watch for pywal color changes
(defun my/watch-pywal-colors ()
  "Set up file watcher for pywal colors.json to auto-reload theme."
  (when (functionp 'file-notify-add-watch)
    (let ((colors-file (expand-file-name "~/.cache/wal/colorscheme.json")))
      (when (file-exists-p colors-file)
        (file-notify-add-watch colors-file '(change)
          (lambda (event)
            (when (eq (nth 1 event) 'changed)
              (reload-pywal-theme))))))))

;; Auto-enable the color watcher when emacs starts
(my/watch-pywal-colors)
#+end_src


* Org-Roam Configuration

My org-roam setup is designed for academic work, using a Zettelkasten-style
knowledge management system with concepts, lectures, readings, and projects.

** Org-Roam UI

Configure org-roam-ui for visual graph navigation of my knowledge base.

#+begin_src emacs-lisp
(use-package! org-roam-ui
  :after org-roam
  :hook (org-roam-mode . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src

** Capture Templates

My capture templates support different types of content in my knowledge system:
- *Lectures* (=l=): Raw notes from lectures with post-processing checklist
- *Concepts* (=c=): Atomic concept nodes with definition, context, relations
- *Readings* (=r=): Paper/book notes with citations
- *Assignments* (=a=): Coursework planning and tracking
- *Projects* (=p=): Personal project overviews
- *Inbox* (=i=): Quick idea capture for later processing
- *Journal* (=j=): Reflective daily/weekly notes

#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-v2-ack t)
  (setq org-roam-capture-templates
        '(("l" "Lecture quicknote" plain
           "%?\n* Post-Lecture Checklist\n- [ ] Extract definitions\n- [ ] Create/update concept node\n- [ ] Link readings\n- [ ] Mark processed"
           :if-new (file+head "academic/lectures/raw/%<%Y-%m-%d>-${slug}.org"
                              "#+TITLE: %<%Y-%m-%d> ${title} Lecture\n#+FILETAGS: :lecture:raw:\n")
           :unnarrowed t)
          ("c" "Concept node" plain
           "* Overview\n%?\n* Context\n* Relations\n* Applications\n* References"
           :if-new (file+head "concepts/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :concept:seed:\n")
           :unnarrowed t)
          ("r" "Reading note" plain
           "* Summary\n%?\n* Key Claims\n* Methods\n* Critical Reflections\n* Links"
           :if-new (file+head "readings/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :reading:seed:\n:PROPERTIES:\n:ROAM_REFS: ${ref}\n:END:\n")
           :unnarrowed t)
          ("a" "Assignment plan" plain
           "* Brief\n%?\n* Requirements\n* Sources\n* Outline\n* Timeline\n* Status"
           :if-new (file+head "assignments/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :assignment:active:\n")
           :unnarrowed t)
          ("p" "Project node" plain
           "* Overview\n%?\n* Goals\n* Links\n* Decisions\n* TODO\n* Resources"
           :if-new (file+head "projects/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :project:active:\n")
           :unnarrowed t)
          ("i" "Inbox idea" plain
           "Context:\n%?\nNext Action:"
           :if-new (file+head "inbox.org" "#+TITLE: Inbox\n#+FILETAGS: :inbox:\n")
           :empty-lines-before 1
           :unnarrowed t)
          ("j" "Journal entry" plain
           "%?"
           :if-new (file+head "journal/%<%Y>.org" "#+TITLE: Journal %<%Y>\n#+FILETAGS: :journal:\n")
           :empty-lines-before 1
           :unnarrowed t)))
#+end_src

** Helper Functions

*** Promote Heading to Concept

This function extracts a heading from a lecture or inbox note and promotes it
to a standalone concept node. The heading's contents are copied into the new
concept file under the =* Overview= section, and a reference link to the original
heading is added to the concept's =* References= section. The original heading
is preserved (not deleted).

#+begin_src emacs-lisp
  (defun my/org-roam-promote-heading-to-concept ()
    "Promote current heading into a new concept node.

This:
- Creates `concepts/<slug>.org` (if missing) with a scaffold that uses '* Overview'.
- Copies the current heading's subtree (content below the heading line) into
  the new file under '* Overview' (appends).
- Transfers the original heading's ID to the new file (if it exists), so existing
  links to that heading automatically resolve to the new concept file.
- Removes the ID from the original heading to avoid duplicates.
- Inserts a link to the new concept in the original file's '* Relations' section as a bullet point.

It does NOT delete or replace the original heading." 
    (interactive)
    (unless (org-at-heading-p)
      (user-error "Not at a heading"))

    (let* ((title (nth 4 (org-heading-components)))
           (node (org-roam-node-create :title title))
           (slug (org-roam-node-slug node))
           (file (expand-file-name (format "concepts/%s.org" slug) org-roam-directory))
           ;; original subtree bounds
           (orig-beg (save-excursion (org-back-to-heading t) (point)))
           (orig-end (save-excursion (org-end-of-subtree t t)))
           ;; body = text after the heading line up to end of subtree
           (body (save-restriction
                   (widen)
                   (when (> orig-end orig-beg)
                     (save-excursion
                       (goto-char orig-beg)
                       (forward-line 1)
                       ;; Skip properties drawer if present
                       (when (looking-at "^[ \t]*:PROPERTIES:")
                         (when (re-search-forward "^[ \t]*:END:" orig-end t)
                           (forward-line 1)))
                       ;; Skip any blank lines after properties
                       (while (and (< (point) orig-end) (looking-at-p "^\\s-*$"))
                         (forward-line 1))
                       ;; Extract the actual content
                       (let ((content-start (point)))
                         (when (< content-start orig-end)
                           (string-trim (buffer-substring-no-properties content-start orig-end)))))))))
      ;; Ensure original heading has an ID so we can link to it later if needed
      (let ((orig-id (save-excursion
                       (org-back-to-heading t)
                       (or (org-entry-get nil "ID")
                           (org-id-get-create)))))
        ;; Create scaffold if file doesn't exist
        (unless (file-exists-p file)
          (with-temp-file file
            (insert ":PROPERTIES:\n:END:\n#+TITLE: " title "\n#+FILETAGS: :concept:seed:\n\n* Overview\n\n* Context\n* Relations\n* Applications\n* References\n")))
        ;; Transfer or create ID: use heading's existing ID if present, otherwise generate new one
        (let ((new-id (if orig-id
                          ;; Use the original heading's ID for the new file
                          (progn
                            (with-current-buffer (find-file-noselect file)
                              (goto-char (point-min))
                              (when (re-search-forward "^:PROPERTIES:" nil t)
                                (forward-line 1)
                                (insert (format ":ID: %s\n" orig-id)))
                              (save-buffer))
                            ;; Delete entire properties drawer from original heading
                            (save-excursion
                              (org-back-to-heading t)
                              (when (re-search-forward "^[ \t]*:PROPERTIES:" (save-excursion (outline-next-heading) (point)) t)
                                (let ((beg (line-beginning-position)))
                                  (when (re-search-forward "^[ \t]*:END:" (save-excursion (outline-next-heading) (point)) t)
                                    (delete-region beg (1+ (line-end-position)))))))
                            (save-buffer)
                            orig-id)
                        ;; No existing ID, generate a new one for the concept file
                        (let ((generated-id (org-id-new)))
                          (with-current-buffer (find-file-noselect file)
                            (goto-char (point-min))
                            (when (re-search-forward "^:PROPERTIES:" nil t)
                              (forward-line 1)
                              (insert (format ":ID: %s\n" generated-id)))
                            (save-buffer))
                          generated-id))))
          ;; Insert body into Overview if present
          (when (and body (not (string-empty-p (string-trim body))))
            (with-current-buffer (find-file-noselect file)
              (save-excursion
                (goto-char (point-min))
                (when (re-search-forward "^\\* Overview\\s-*$" nil t)
                  (forward-line 1)
                  ;; Clean up: remove any existing blank lines after Overview heading
                  (while (looking-at-p "^\\s-*$")
                    (delete-region (line-beginning-position) (1+ (line-end-position))))
                  ;; Insert the trimmed body content
                  (insert (string-trim body) "\n")
                  (save-buffer)))))

          ;; Insert a link to the NEW concept into the original file's *Relations section
          (save-excursion
            (goto-char (point-min))
            (if (re-search-forward "^\\* Relations\\s-*$" nil t)
                ;; Found Relations section, insert link
                (progn
                  (forward-line 1)
                  (insert (format "- [[id:%s][%s]]\n" new-id title))
                  (save-buffer))
              ;; No Relations section, create one at end of file
              (goto-char (point-max))
              (unless (bolp) (insert "\n"))
              (insert (format "* Relations\n- [[id:%s][%s]]\n" new-id title))
              (save-buffer)))
          (message "Promoted '%s' → %s (id:%s) and inserted link in original file" title file new-id)))))
#+end_src

*** Insert File Link

Insert a link to an external file (useful for linking to project files, GitHub repos, etc).

#+begin_src emacs-lisp
  (defun my/insert-file-link (path)
    "Insert an org file link to PATH with basename as description."
    (interactive "fFile: ")
    (insert (format "[[file:%s][%s]]" (abbreviate-file-name path) (file-name-base path))))
#+end_src

*** Add Heading ID

Add a UUID to a heading with a human-readable alias for easier referencing.

#+begin_src emacs-lisp
  (defun my/add-heading-id ()
    "Add org-id UUID to heading with filename-heading alias for org-roam."
    (interactive)
    (org-back-to-heading t)
    (let* ((filename (file-name-base (buffer-file-name)))
           (title (nth 4 (org-heading-components)))
           (alias (format "%s - %s" filename title))
           (id (org-id-get-create)))
      (org-set-property "ROAM_ALIASES" (format "\"%s\"" alias))
      (message "Added ID with alias: %s" alias)))
#+end_src

*** Insert Heading Link

Interactive function to pick an org file and heading, then insert a link with proper ID.

#+begin_src emacs-lisp
  (defun my/insert-heading-link ()
    "Pick an org file recursively, then link to a heading with org-id."
    (interactive)
    (let* ((current-buf (current-buffer))
           (brain2-dir (expand-file-name "~/Documents/brain2/"))
           (default-directory brain2-dir)
           ;; Get all org files recursively
           (org-files (directory-files-recursively brain2-dir "\\.org$"))
           ;; Make paths relative for cleaner display
           (file-choices (mapcar (lambda (f) (file-relative-name f brain2-dir)) org-files))
           (file-rel (completing-read "Org file: " file-choices nil t))
           (file (expand-file-name file-rel brain2-dir))
           (filename (file-name-base file)))
      (unless (file-exists-p file)
        (user-error "File not found: %s" file))
      ;; List headings in that file
      (with-current-buffer (find-file-noselect file)
        (let* ((headings (org-map-entries (lambda () (nth 4 (org-heading-components))) nil 'file))
               (heading (completing-read "Heading: " headings)))
          ;; Find the heading and get/create its ID
          (goto-char (point-min))
          (unless (search-forward heading nil t)
            (user-error "Heading not found: %s" heading))
          (org-back-to-heading t)
          (let* ((id (org-id-get-create))
                 (alias (format "%s - %s" filename heading))
                 (link (format "[[id:%s][%s]]" id heading)))
            ;; Ensure alias is set
            (unless (org-entry-get nil "ROAM_ALIASES")
              (org-set-property "ROAM_ALIASES" (format "\"%s\"" alias)))
            ;; Switch back to original buffer and insert link
            (with-current-buffer current-buf
              (insert link)
              (message "Inserted link: %s" link)))))))
#+end_src

** Keybindings

All org-roam related keybindings are under the =SPC n= prefix.

#+begin_src emacs-lisp
  (map! :leader
        :desc "Promote heading to concept" "n P" #'my/org-roam-promote-heading-to-concept
        :desc "Insert file link" "n f" #'my/insert-file-link
        :desc "Add heading ID" "n i" #'my/add-heading-id
        :desc "Insert heading link" "n h" #'my/insert-heading-link
        :desc "Find/create node" "n n" #'org-roam-node-find
        :desc "Insert node link" "n l" #'org-roam-node-insert
        :desc "Toggle backlinks" "n b" #'org-roam-buffer-toggle
        :desc "Open graph UI" "n g" #'org-roam-ui-open
        :desc "Capture new node" "n c" #'org-roam-capture)
#+end_src

Close the =after! org-roam= block:

#+begin_src emacs-lisp
)
#+end_src

* Lecture Processing

Helper function to mark a lecture as processed and move it from =raw/= to =processed/=.

#+begin_src emacs-lisp
(defun my/mark-lecture-processed ()
  "Mark current lecture note as processed and move to processed directory."
  (interactive)
  (let* ((file (buffer-file-name))
         (rel (file-relative-name file org-roam-directory)))
    (unless (string-match-p "academic/lectures/raw/" rel)
      (user-error "Not in raw lectures directory"))
    (save-excursion
      (goto-char (point-min))
      (unless (re-search-forward "POST-LECTURE CHECKLIST" nil t)
        (goto-char (point-max)))
      (save-buffer)
      (org-set-property "PROCESSED" (format-time-string "%Y-%m-%d")))
    (let* ((dest (expand-file-name (concat "academic/lectures/processed/" (file-name-nondirectory file)) org-roam-directory)))
      (rename-file file dest 1)
      (find-file dest)
      (message "Lecture processed & moved."))))

(map! :leader :desc "Process lecture" "n L" #'my/mark-lecture-processed)
#+end_src

* File Navigation

Use =consult-fd= for live, telescope-like file finding without caching.

#+begin_src emacs-lisp
(map! :leader :desc "Find file (live)" "SPC" #'consult-fd)
#+end_src

** Performance: Fast Search Tools

Configure Emacs to use modern fast tools (fd, ripgrep) for all search operations.

#+begin_src emacs-lisp
;; Use fd instead of find for projectile
(after! projectile
  (when (executable-find "fd")
    (setq projectile-git-command "fd . -0 --type f --color=never"
          projectile-generic-command "fd . -0 --type f --color=never"
          projectile-indexing-method 'alien
          projectile-enable-caching nil)))  ; No cache needed with fd

;; Use ripgrep for project search
(after! counsel
  (when (executable-find "rg")
    (setq counsel-rg-base-command "rg --no-heading --line-number --color never %s .")))

;; Configure consult to use ripgrep and fd
(after! consult
  (when (executable-find "rg")
    (setq consult-ripgrep-args "rg --null --line-buffered --color=never --max-columns=1000 --path-separator / --smart-case --no-heading --with-filename --line-number --search-zip"))
  (when (executable-find "fd")
    (setq consult-fd-args "fd --color=never --full-path --hidden --exclude .git")))

;; Use ripgrep for Doom's default search
(after! vertico
  (when (executable-find "rg")
    (setq +default-want-RET-continue-p nil)))
#+end_src

** Yazi Integration (eee.el)

Launch yazi file manager in external terminal with Emacs integration.

#+begin_src emacs-lisp
(use-package! eee
  :config
  ;; Use wrapper script that applies transparency state to new st windows
  (setq ee-terminal-command "/home/croc/.config/scripts/st-with-transparency")
  
  ;; Keybindings for yazi and other TUI tools
  (map! :leader
        :desc "Yazi (current dir)" "f y" #'ee-yazi
        :desc "Yazi (project)" "f Y" #'ee-yazi-project
        :desc "Ripgrep search" "s g" #'ee-rg
        :desc "Lazygit" "g z" #'ee-lazygit))
#+end_src

* AI Integration: GPTel

GPTel provides AI assistance directly in Emacs. 

#+begin_src emacs-lisp
(use-package! gptel
  :config
  (setq gptel-model 'gpt-5-mini
        gptel-backend (gptel-make-gh-copilot "Copilot")))
#+end_src

To use GPTel:
- =M-x gptel= -- Open a chat buffer
- =M-x gptel-menu= -- Select model/backend
- In org-mode, select region and send to gptel for processing

* Discord Presence

Show your Emacs activity on Discord using emacs-rpc.
Lazy-loaded to avoid startup overhead.

#+begin_src emacs-lisp
(use-package! presence
  :defer 5  ; Load 5 seconds after startup (lazy-load for performance)
  :commands (presence-mode)
  :init
  ;; Don't auto-enable, let it load lazily
  (run-with-idle-timer 5 nil #'presence-mode)
  :config
  ;; Use custom Discord application
  (setq presence-client-id "1443438985878962228")
  ;; Use asset keys directly (not URLs) for our custom Discord app
  (setq presence-icon-base nil)
  ;; Override to return just the asset key
  (defun presence--resolve-icon-base (icon)
    "Return just the icon asset key for Discord."
    icon)
  ;; Use custom icon from our Discord app
  (setq presence-editor-icon "emacs-icon")
  ;; Keep editor as main icon, mode as small icon
  (setq presence-use-major-mode-as-main-icon nil)
  ;; Show the small icon (mode icon)
  (setq presence-show-small-icon t)
  ;; Add extra mode icon mappings
  (setq presence-mode-icon-alist
        (append '((magit-status-mode . "git")
                  (magit-log-mode . "git")
                  (magit-diff-mode . "git")
                  (magit-revision-mode . "git")
                  (conf-toml-mode . "toml"))
                presence-mode-icon-alist))
  ;; Hide line numbers from status
  (setq presence-display-line-numbers nil)
  ;; Custom format: show project name + file instead of just buffer name
  (defun my/presence-buffer-details ()
    (let ((project (projectile-project-name))
          (file (buffer-name)))
      (if (and project (not (string= project "-")))
          (format "In %s: %s" project file)
        (format "Editing %s" file))))
  (setq presence-buffer-details-format-function #'my/presence-buffer-details))
#+end_src

* Org Agenda

Configure org-agenda to search the entire brain2 directory for TODOs and scheduled items.

#+begin_src emacs-lisp
(after! org
  (setq org-agenda-files '("~/Documents/brain2/")
        org-hide-emphasis-markers t)
  ;; Fallback: ensure emphasis markers are hidden when org-mode starts
  (add-hook 'org-mode-hook (lambda () (setq org-hide-emphasis-markers t))))
#+end_src

* Org Formatting

Automatically format org files with consistent spacing:
- No blank line between heading and properties drawer
- Blank line after properties drawer before content
- Blank line after headings before content

#+begin_src emacs-lisp
(after! org
  (defun my/org-format-buffer ()
    "Format org buffer with consistent spacing."
    (interactive)
    (message "Running org-format-buffer...")
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\*+ " nil t)
        (let ((heading-pos (line-beginning-position)))
          ;; Check if next line is properties drawer
          (forward-line 1)
          (when (looking-at "^[ \t]*:PROPERTIES:")
            ;; Remove any blank lines between heading and properties
            (goto-char heading-pos)
            (forward-line 1)
            (while (and (not (looking-at "^[ \t]*:PROPERTIES:"))
                       (looking-at-p "^\\s-*$"))
              (delete-region (line-beginning-position) (1+ (line-end-position))))
            ;; Find end of properties
            (when (re-search-forward "^[ \t]*:END:" nil t)
              (forward-line 1)
              ;; Ensure exactly one blank line after properties
              (let ((content-start (point)))
                (while (looking-at-p "^\\s-*$")
                  (forward-line 1))
                (unless (= (point) (1+ content-start))
                  (delete-region content-start (point))
                  (goto-char content-start)
                  (unless (or (looking-at "^\\*") (eobp))
                    (insert "\n"))))))
          ;; If no properties, ensure blank line after heading
          (goto-char heading-pos)
          (forward-line 1)
          (unless (or (looking-at "^[ \t]*:PROPERTIES:")
                     (looking-at-p "^\\s-*$")
                     (looking-at "^\\*")
                     (eobp))
            (insert "\n")))))
    
    ;; Ensure blank line before each heading (after content)
    (save-excursion
      (goto-char (point-min))
      ;; Skip first heading
      (when (re-search-forward "^\\*+ " nil t)
        (beginning-of-line)
        (while (re-search-forward "^\\*+ " nil t)
          (beginning-of-line)
          (let ((heading-pos (point)))
            (forward-line -1)
            ;; If previous line is not blank and not a heading, add blank line
            (when (and (not (looking-at-p "^\\s-*$"))
                       (not (looking-at "^\\*")))
              (end-of-line)
              (insert "\n"))
            ;; Move past this heading to continue loop
            (goto-char heading-pos)
            (forward-line 1))))))
  
   ;; Run formatting on save
   (add-hook 'org-mode-hook
     (lambda ()
       (add-hook 'before-save-hook #'my/org-format-buffer nil t))))
#+end_src

* Zen Mode Customization

Configure zen mode (writeroom-mode) with smaller font, wider margins, no line numbers, and hidden org stars.

#+begin_src emacs-lisp
(setq +zen-text-scale 1)           ;; Font size scale (1 = one size larger)
(setq writeroom-width 70)          ;; Column width (narrower = wider margins)

;; Configure org-modern to always be on for org-mode
(after! org-modern
  (setq org-modern-hide-stars 'leading)
  ;; Enable org-modern globally
  (add-hook 'org-mode-hook #'org-modern-mode))

;; Zen mode hook - hide line numbers, adjust org-modern star display
(add-hook 'writeroom-mode-hook
  (lambda ()
    (if writeroom-mode
        (progn
          (display-line-numbers-mode -1)
          (when (derived-mode-p 'org-mode)
            (setq-local org-modern-hide-stars t))
          (text-scale-set 1))
      (progn
        ;; Restore when exiting zen mode
        (display-line-numbers-mode 1)
        (when (derived-mode-p 'org-mode)
          (setq-local org-modern-hide-stars 'leading))))))
#+end_src



* Dashboard Customization

#+begin_src emacs-lisp
;; Use custom emacs logo image as the dashboard banner with minimal menu.

;; Set BEFORE doom-dashboard loads - use pre-scaled high-quality XPM
(setq +doom-dashboard-banner-file "default.xpm"
      +doom-dashboard-banner-dir (expand-file-name "~/.config/emacs/modules/ui/doom-dashboard/banners/"))

(setq +doom-dashboard-menu-sections
      '((" Open project"
         :action projectile-switch-project)
        (" Open documentation"
         :action doom/help)))

(after! doom-dashboard

  ;; Adjust banner padding for better vertical centering
  (setq +doom-dashboard-banner-padding '(8 . 4))

  ;; Override the banner widget to properly center the image
  (defun doom-dashboard-widget-banner ()
    (let ((point (point)))
      (if (and (display-graphic-p)
               (stringp fancy-splash-image)
               (file-readable-p fancy-splash-image))
          (let* ((image (create-image (fancy-splash-image-file)))
                 (img-width (car (image-size image t)))
                 ;; Add 2 extra spaces to shift right slightly
                 (line (make-string (max 1 (+ img-width 2)) ? )))
            ;; Insert a centered spacer line and display the image on it
            (insert (+doom-dashboard--center +doom-dashboard--width line) "\n")
            (add-text-properties
             point (1- (point)) `(display ,image rear-nonsticky (display)))
            (insert (make-string (or (cdr +doom-dashboard-banner-padding) 0)
                                 ?\n)))
        ;; Fallback to ASCII banner in terminal mode (optional)
        nil)))

  ;; Custom shortmenu with tighter spacing - use single newline instead of double
  (defun my/doom-dashboard-widget-shortmenu ()
    (insert "\n")
    (dolist (section +doom-dashboard-menu-sections)
      (cl-destructuring-bind (label &key icon action when face key) section
        (when (and (fboundp action)
                   (or (null when)
                       (eval when t)))
          (insert
           (+doom-dashboard--center
            (- +doom-dashboard--width 1)
            (let ((icon (if (stringp icon) icon (eval icon t))))
              (format (format "%s%%s%%-10s" (if icon "%3s\t" "%3s"))
                      (or icon "")
                      (with-temp-buffer
                        (insert-text-button
                         label
                         'action
                         `(lambda (_)
                            (call-interactively (or (command-remapping #',action)
                                                    #',action)))
                         'face (or face 'doom-dashboard-menu-title)
                         'follow-link t
                         'help-echo
                         (format "%s (%s)" label
                                 (propertize (symbol-name action) 'face 'doom-dashboard-menu-desc)))
                        (format "%-37s" (buffer-string)))
                      ;; Lookup command keys dynamically
                      (propertize
                       (or key
                           (when-let*
                               ((keymaps
                                 (delq
                                  nil (list (when (bound-and-true-p evil-local-mode)
                                              (evil-get-auxiliary-keymap +doom-dashboard-mode-map 'normal))
                                            +doom-dashboard-mode-map)))
                                (key
                                 (or (when keymaps
                                       (where-is-internal action keymaps t))
                                     (where-is-internal action nil t))))
                             (with-temp-buffer
                               (save-excursion (insert (key-description key)))
                               (while (re-search-forward "<\\([^>]+\\)>" nil t)
                                 (let ((str (match-string 1)))
                                   (replace-match
                                    (upcase (if (< (length str) 3)
                                                str
                                              (substring str 0 3))))))
                               (buffer-string)))
                           "")
                       'face 'doom-dashboard-menu-desc))))
           "\n")))))  ;; Use single \n instead of \n\n

  ;; Override dashboard widgets - remove loaded time, keep banner and menu
  (setq +doom-dashboard-functions
        '(doom-dashboard-widget-banner
          my/doom-dashboard-widget-shortmenu
          doom-dashboard-widget-footer))

  ;; Force reload dashboard to apply changes
  (when (get-buffer +doom-dashboard-name)
    (+doom-dashboard-reload t)))
#+end_src

* Vterm Configuration

The problem: Evil intercepts ESC globally before vterm can handle it.
The solution: Disable Evil's ESC keybinding in vterm buffers.

#+begin_src emacs-lisp
(after! vterm
  (add-hook 'vterm-mode-hook
    (lambda ()
      ;; ESC sends to terminal, not evil
      (evil-define-key 'insert vterm-mode-map
        (kbd "<escape>") 'vterm-send-escape)
      ;; Ctrl-c Ctrl-c enters normal mode
      (evil-define-key 'insert vterm-mode-map
        (kbd "C-c C-c") 'evil-normal-state))))
#+end_src

<!-- Local Variables: -->
<!-- gptel-model: gpt-5-mini -->
<!-- gptel--backend-name: "Copilot" -->
<!-- gptel--bounds: nil -->
<!-- End: -->
