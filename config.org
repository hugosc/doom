#+TITLE: Doom Emacs Configuration
#+AUTHOR: Crocodile
#+PROPERTY: header-args :tangle yes :cache yes :results silent :padline no

* Table of Contents :TOC:

- [[#introduction][Introduction]]
- [[#basic-settings][Basic Settings]]
  - [[#directories][Directories]]
  - [[#org-attach-configuration][Org-Attach Configuration]]
  - [[#emacs-server][Emacs Server]]
  - [[#epg-and-gpg-configuration][EPG and GPG Configuration]]
  - [[#auto-revert-mode][Auto-revert Mode]]
  - [[#user-information][User Information]]
  - [[#line-numbers][Line Numbers]]
  - [[#browser-configuration][Browser Configuration]]
  - [[#performance-tuning][Performance Tuning]]
  - [[#writing-aids-spell-and-grammar][Writing Aids (Spell and Grammar)]]
- [[#visual-configuration][Visual Configuration]]
  - [[#fonts][Fonts]]
  - [[#theme-pywal-integration][Theme: Pywal Integration]]
  - [[#transparency-toggle-and-pywal-auto-reload][Transparency Toggle and Pywal Auto-Reload]]
  - [[#theme-conversion-tools][Theme Conversion Tools]]
- [[#org-roam-configuration][Org-Roam Configuration]]
  - [[#org-roam-ui][Org-Roam UI]]
  - [[#capture-templates][Capture Templates]]
  - [[#org-roam-dailies][Org-Roam Dailies]]
  - [[#helper-functions][Helper Functions]]
  - [[#smart-image-pasting][Smart Image Pasting]]
  - [[#keybindings][Keybindings]]
  - [[#buffer-navigation][Buffer Navigation]]
- [[#lecture-processing][Lecture Processing]]
- [[#file-navigation][File Navigation]]
  - [[#performance-fast-search-tools][Performance: Fast Search Tools]]
  - [[#yazi-integration-eeeel][Yazi Integration (eee.el)]]
  - [[#dired-configuration][Dired Configuration]]
- [[#rust-configuration][Rust Configuration]]
- [[#ai-integration-copilot][AI Integration: Copilot]]
- [[#ai-integration-gptel][AI Integration: GPTel]]
  - [[#core-configuration][Core Configuration]]
  - [[#gptel-agent][GPTel Agent]]
  - [[#usage-guide][Usage Guide]]
- [[#discord-presence][Discord Presence]]
- [[#org-todo][Org-Todo]]
- [[#org-agenda][Org Agenda]]
- [[#google-calendar-integration][Google Calendar Integration]]
  - [[#setup-instructions][Setup Instructions]]
  - [[#configuration][Configuration]]
  - [[#calfw-theme-integration][Calfw Theme Integration]]
  - [[#usage][Usage]]
- [[#org-pomodoro-configuration][Org-Pomodoro Configuration]]
- [[#org-formatting][Org Formatting]]
- [[#org-inline-images][Org Inline Images]]
  - [[#unified-image-display-for-org-download][Unified Image Display for Org-Download]]
- [[#zen-mode-customization][Zen Mode Customization]]
- [[#dashboard-customization][Dashboard Customization]]
- [[#pdf-configuration][PDF Configuration]]
- [[#vterm-configuration][Vterm Configuration]]
- [[#circe-irc-configuration][Circe IRC Configuration]]

* Introduction

This is my Doom Emacs configuration, written in a literate style using org-mode.
The configuration is focused on academic work with org-roam for knowledge management
and GPTel for AI assistance via GitHub Copilot.

* Basic Settings

** Directories

Set the org-roam directory to my brain2 vault. This must be set before org-roam loads.
#+begin_src emacs-lisp
(setq org-roam-directory "~/Documents/brain2")
#+end_src
Set the general org-directory for agenda and other org features.
#+begin_src emacs-lisp
(setq org-directory "~/Documents/brain2/")
#+end_src

** Org-Attach Configuration

Configure org-attach for per-heading attachments.
Each heading with attachments gets its own directory.
#+begin_src emacs-lisp
(after! org-attach
  ;; DISABLE inheritance - each heading gets its own attachment directory
  ;; This allows multiple headings per daily note to have separate attachments
  (setq org-attach-use-inheritance nil)
  ;; Store attachments in .attach/ subdirectory (Doom default)
  (setq org-attach-id-dir ".attach/")
  ;; Use UUID folder format: first 2 chars as parent dir, rest as subdirectory
  (setq org-attach-id-to-path-function-list 
        '(org-attach-id-uuid-folder-format)))
;; Configure org-download to work with heading-level attachments
(after! org-download
  ;; Don't organize by heading level - let org-attach handle the structure
  (setq org-download-heading-lvl nil)
  ;; Don't add annotations to image links
  (setq org-download-annotate-function (lambda (_link) "")))
#+end_src

** Emacs Server

Start the emacs server to allow emacsclient connections (required for pywal hooks).
When running in daemon mode, server is already started automatically.
#+begin_src emacs-lisp
;; Only start server if NOT already in daemon mode
(unless (daemonp)
  (require 'server)
  (unless (server-running-p)
    (server-start)))
#+end_src

** EPG and GPG Configuration

Configure Emacs Privacy Guard (EPG) for proper GPG integration with plstore and org-gcal.
#+begin_src emacs-lisp
;; Use GPG agent for password prompts
(setq epg-gpg-program "gpg")
(setq epg-pinentry-mode 'loopback)
;; Cache GPG passphrase in Emacs to avoid repeated prompts
(setq epg-passphrase-alist nil)
(defun my/cache-gpg-passphrase (context handback)
  "Cache GPG passphrase for this session."
  (let ((passphrase (read-passwd "GPG Passphrase: ")))
    (setf (alist-get context epg-passphrase-alist) passphrase)
    passphrase))
(setq epg-ask-passphrase-function #'my/cache-gpg-passphrase)
;; Auto-save plstore without prompting (for oauth tokens)
(setq plstore-cache-passphrase-for-symmetric-encryption t)
;; Ensure GPG can find the agent
(unless (getenv "GPG_AGENT_INFO")
  (let ((agent-sock (format "~/.gnupg/S.gpg-agent")))
    (when (file-exists-p (expand-file-name agent-sock))
      (setenv "GPG_AGENT_INFO" (format "%s:0:1" (expand-file-name agent-sock))))))
#+end_src

** Auto-revert Mode

Enable global auto-revert mode to automatically reload files when they change externally.
This is especially useful when working with external tools like OpenCode.
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(setq auto-revert-interval 20)   ; Check every 20 seconds (less aggressive)
(setq auto-revert-verbose nil)   ; Don't spam messages
#+end_src

** User Information

Configure user information for GPG, email clients, and file templates.
#+begin_src emacs-lisp
;; (setq user-full-name "John Doe"
;;       user-mail-address "john@doe.com")
#+end_src

** Line Numbers

Display line numbers in programming and text modes.
 #+begin_src emacs-lisp
 (setq display-line-numbers-type t)
 #+end_src

** Visual Line Motion (Wrapped Lines)

Enable soft-wrapping for notes, and make Evil `j`/`k` move by *visual* (screen) lines
when lines wrap.

#+begin_src emacs-lisp
;; Prefer Emacs' visual line wrapping for prose/note-taking.
(add-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'org-mode-hook  #'visual-line-mode)

;; Make Evil motions follow wrapped (screen) lines.
(after! evil
  (setq evil-respect-visual-line-mode t)

  ;; Like common Neovim setups: j/k => visual lines, gj/gk => logical lines.
  (map! :map evil-motion-state-map
        "j"  #'evil-next-visual-line
        "k"  #'evil-previous-visual-line
        "gj" #'evil-next-line
        "gk" #'evil-previous-line
        :map evil-normal-state-map
        "j"  #'evil-next-visual-line
        "k"  #'evil-previous-visual-line
        "gj" #'evil-next-line
        "gk" #'evil-previous-line))
#+end_src

** Browser Configuration

Set Helium as the system default browser (handled by xdg-mime).
Emacs will use the system default automatically.
#+begin_src emacs-lisp
;; Use system default browser (set via xdg-mime)
(setq browse-url-browser-function 'browse-url-default-browser)
#+end_src

** Performance Tuning

#+begin_src emacs-lisp
;; Don't check VC info during auto-revert (much faster)
(setq auto-revert-check-vc-info nil)
#+end_src

** Writing Aids (Spell and Grammar)

Doom's `:checkers spell` module enables on-the-fly spell checking (squiggles) in
many text modes (org/markdown/git commit, etc). Dictionary comes from
`ispell-dictionary`.
#+begin_src emacs-lisp
(after! ispell
  ;; Match your installed hunspell dictionaries (see `hunspell -D`).
  (setq ispell-dictionary "en_GB"))
#+end_src
The `:checkers grammar` module integrates LanguageTool (via `langtool`) plus
`writegood-mode`. LanguageTool itself is an external dependency; on Arch it's
typically `pacman -S languagetool`. After installing it, you can use:
`M-x langtool-check` / `M-x langtool-correct-buffer`.
#+begin_src emacs-lisp
(after! langtool
  (setq langtool-default-language "en-GB"))
#+end_src

* Visual Configuration

** Fonts

Doom exposes five font variables for customization:
- =doom-font= -- the primary font to use
- =doom-variable-pitch-font= -- a non-monospace font (where applicable)
- =doom-big-font= -- used for =doom-big-font-mode=
- =doom-symbol-font= -- for symbols
- =doom-serif-font= -- for the =fixed-pitch-serif= face
Fonts are left at Doom defaults. Zen mode configures its own font sizing.

** Theme: Pywal Integration

I use =ewal= to integrate pywal colors with Doom themes, allowing my Emacs theme
to automatically match my wallpaper color scheme.
#+begin_src emacs-lisp
;; Set doom-theme early to force ewal-doom-one to load during init
;; This prevents the flash of default theme on cold start
(setq doom-theme 'ewal-doom-one)
(use-package! ewal
  :init (setq ewal-use-built-in-always-p nil
              ewal-use-built-in-on-failure-p t
              ewal-built-in-palette "doom-one"))
(use-package! ewal-doom-themes
  :after ewal
  :config (progn
            ;; Load our ewal fix - prefer compiled version for speed
            (let ((compiled-file (expand-file-name "~/.config/doom/ewal-fix.elc"))
                  (source-file (expand-file-name "~/.config/doom/ewal-fix.el")))
              (if (and (file-exists-p compiled-file)
                       (file-newer-than-file-p compiled-file source-file))
                  (load compiled-file)
                (load source-file)))
            (load-theme 'ewal-doom-one t)
            (enable-theme 'ewal-doom-one)))
#+end_src
Helper functions for smart theme loading - detects doom presets vs wallpaper themes:
#+begin_src emacs-lisp
(defvar my/preset-theme-cache nil
  "Cache for preset theme detection to avoid repeated JSON parsing.")
(defun my/detect-preset-theme (&optional force-refresh)
  "Detect which preset theme is currently active from pywal cache.
Returns (TYPE . NAME) where TYPE is 'doom or 'other, and NAME is the theme name.
For doom themes: NAME is like 'gruvbox-light' (without 'doom-' prefix).
For other themes: NAME is the full theme symbol like 'kuronami or 'wombat.
Returns nil if not a preset theme (wallpaper-based).
Uses caching for performance - pass FORCE-REFRESH to bypass cache."
  (let* ((cache-file (expand-file-name "~/.cache/wal/colors.json"))
         (preset-dir (expand-file-name "~/.config/wal/colorschemes/dark/")))
    (when (file-exists-p cache-file)
      ;; Check cache validity
      (if (and my/preset-theme-cache
               (not force-refresh)
               (equal (nth 5 (file-attributes cache-file))
                      (car my/preset-theme-cache)))
          ;; Return cached result
          (cdr my/preset-theme-cache)
        
        ;; Cache miss or expired - recompute
        (let* ((json-object-type 'alist)
               (json-array-type 'list)
               (current-colors (json-read-file cache-file))
               (current-bg (alist-get 'background (alist-get 'special current-colors)))
               (current-fg (alist-get 'foreground (alist-get 'special current-colors)))
               (current-c0 (alist-get 'color0 (alist-get 'colors current-colors)))
               (result nil))
          
          ;; Check all preset files for a match
          (catch 'found
            (dolist (file (directory-files preset-dir nil "\\.json$"))
              (let* ((preset-path (expand-file-name file preset-dir))
                     (preset-colors (json-read-file preset-path))
                     (preset-bg (alist-get 'background (alist-get 'special preset-colors)))
                     (preset-fg (alist-get 'foreground (alist-get 'special preset-colors)))
                     (preset-c0 (alist-get 'color0 (alist-get 'colors preset-colors))))
                
                ;; Match if bg, fg, and color0 all match
                (when (and (string= current-bg preset-bg)
                          (string= current-fg preset-fg)
                          (string= current-c0 preset-c0))
                  ;; Check if it's a doom theme or other theme
                  (setq result
                        (if (string-match "^doom-\\(.*\\)\\.json$" file)
                            ;; Doom theme: return ('doom . "gruvbox-light")
                            (cons 'doom (match-string 1 file))
                          ;; Other theme: return ('other . 'kuronami)
                          (cons 'other 
                                (intern (replace-regexp-in-string "\\.json$" "" file)))))
                  (throw 'found result)))))
          
          ;; Update cache with file timestamp and result
          (setq my/preset-theme-cache 
                (cons (nth 5 (file-attributes cache-file)) result))
          result)))))
(defun reload-pywal-theme ()
  "Reload theme - use original doom theme if preset, else use ewal.
Properly handles org-roam-ui websocket server to prevent port conflicts."
  (interactive)
  (let* ((colors-file (expand-file-name "~/.cache/wal/colors.json"))
         (json-object-type 'alist)
         (json-array-type 'list)
         (colors (json-read-file colors-file))
         (wallpaper (alist-get 'wallpaper colors))
         ;; Check if wallpaper is actual path (not "None" string)
         (is-wallpaper-based (and wallpaper 
                                  (not (string= wallpaper "None"))
                                  (file-exists-p wallpaper)))
         ;; Save org-roam-ui state before theme change
         (org-roam-ui-was-active (and (featurep 'org-roam-ui)
                                       (bound-and-true-p org-roam-ui-mode))))
    
    ;; Step 1: Stop org-roam-ui if running to prevent websocket port conflict
    (when org-roam-ui-was-active
      (org-roam-ui-mode -1)
      (message "Stopped org-roam-ui for theme reload..."))
    
    ;; Step 2: Disable all old themes first to avoid conflicts
    (mapc #'disable-theme custom-enabled-themes)
    
    ;; Step 3: Load the appropriate theme
    (if is-wallpaper-based
        ;; Wallpaper-based theme: use ewal with our fixes
        (progn
          (ewal-load-colors)
          (load-theme 'ewal-doom-one t)
          (message "Pywal theme reloaded (wallpaper-based)"))
      
      ;; No wallpaper or "None" = preset theme: try to load original theme
      ;; Force refresh cache since pywal colors just changed
      (let* ((preset-info (my/detect-preset-theme t))
             (preset-type (car preset-info))
             (preset-name (cdr preset-info)))
        (cond
         ;; Doom preset theme
         ((eq preset-type 'doom)
          (let ((theme-symbol (intern (concat "doom-" preset-name))))
            (if (member theme-symbol (custom-available-themes))
                (progn
                  (load-theme theme-symbol t)
                  (message "Loaded original doom theme: %s" theme-symbol))
              ;; Fallback to ewal if doom theme not found
              (progn
                (ewal-load-colors)
                (load-theme 'ewal-doom-one t)
                (message "Doom theme %s not found, using ewal" theme-symbol)))))
         
         ;; Other preset theme (kuronami, wombat, etc.)
         ((eq preset-type 'other)
          (if (member preset-name (custom-available-themes))
              (progn
                (load-theme preset-name t)
                (message "Loaded original theme: %s" preset-name))
            ;; Fallback to ewal if theme not found
            (progn
              (ewal-load-colors)
              (load-theme 'ewal-doom-one t)
              (message "Theme %s not found, using ewal" preset-name))))
         
         ;; No preset detected, use ewal
         (t
          (ewal-load-colors)
          (load-theme 'ewal-doom-one t)
          (message "Pywal theme reloaded (preset fallback to ewal)")))))
    
    ;; Step 4: Restart org-roam-ui if it was running before
    (when org-roam-ui-was-active
      ;; Small delay to ensure theme is fully loaded
      (run-at-time 0.3 nil 
                   (lambda ()
                     (org-roam-ui-mode 1)
                     (message "Restarted org-roam-ui after theme reload"))))))
#+end_src

** Transparency Toggle and Pywal Auto-Reload

Unified transparency system that syncs across kitty, st, and emacs.
Uses Super+Shift+P (via DWM) to toggle all windows simultaneously.
State is persisted in ~/.cache/transparency-state and copied to /tmp on startup.
#+begin_src emacs-lisp
;; Initialize transparency state (fast, runs synchronously on startup)
(let ((temp-state "/tmp/transparency-state")
      (persistent-state (expand-file-name "~/.cache/transparency-state")))
  ;; If temp state doesn't exist, restore from persistent or create default
  (unless (file-exists-p temp-state)
    (if (file-exists-p persistent-state)
        (copy-file persistent-state temp-state t)
      (with-temp-file temp-state (insert "transparent"))
      (with-temp-file persistent-state (insert "transparent")))))
;; Read transparency state from file (inline for speed)
(defun get-transparency-state ()
  "Read current transparency state from /tmp/transparency-state."
  (if (file-exists-p "/tmp/transparency-state")
      (with-temp-buffer
        (insert-file-contents "/tmp/transparency-state")
        (string-trim (buffer-string)))
    "transparent"))
;; Set initial transparency based on saved state
(let ((state (get-transparency-state)))
  (set-frame-parameter nil 'alpha-background 
                       (if (string= state "opaque") 100 85)))
;; Apply transparency to all new frames (fixes emacsclient frame creation)
(defun my/apply-transparency-to-frame (frame)
  "Apply transparency state to newly created FRAME."
  (let ((state (get-transparency-state)))
    (set-frame-parameter frame 'alpha-background 
                         (if (string= state "opaque") 100 85))))
;; Hook into frame creation for emacsclient windows
(add-hook 'after-make-frame-functions #'my/apply-transparency-to-frame)
;; Toggle function that syncs with system
(defun toggle-emacs-transparency ()
  "Toggle emacs frame transparency and sync with system state."
  (interactive)
  ;; Just call the system-wide toggle script which handles everything
  (start-process-shell-command 
   "toggle-transparency" nil "~/.config/scripts/system/toggle-transparency"))
;; Watch for transparency state changes from external toggles (async, no startup impact)
(when (functionp 'file-notify-add-watch)
  (let ((state-file "/tmp/transparency-state"))
    (file-notify-add-watch state-file '(change)
      (lambda (event)
        (when (eq (nth 1 event) 'changed)
          (let ((state (get-transparency-state)))
            (dolist (frame (frame-list))
              (set-frame-parameter frame 'alpha-background 
                                   (if (string= state "opaque") 100 85)))))))))
;; Watch for pywal color changes
(defvar my/pywal-reload-timer nil
  "Timer for debouncing pywal theme reloads.")
(defun my/watch-pywal-colors ()
  "Set up file watcher for pywal colors.json to auto-reload theme.
Debounced to prevent duplicate reloads when multiple hooks trigger."
  (when (functionp 'file-notify-add-watch)
    (let ((colors-file (expand-file-name "~/.cache/wal/colors.json")))
      (when (file-exists-p colors-file)
        (file-notify-add-watch colors-file '(change)
          (lambda (event)
            (when (eq (nth 1 event) 'changed)
              ;; Cancel existing timer to debounce
              (when my/pywal-reload-timer
                (cancel-timer my/pywal-reload-timer))
              ;; Set new timer - reload after 0.2s of no changes
              (setq my/pywal-reload-timer
                    (run-at-time 0.2 nil #'reload-pywal-theme)))))))))
;; Auto-enable the color watcher when emacs starts
(my/watch-pywal-colors)
#+end_src

** Theme Conversion Tools

Load the theme-to-pywal script only when needed (lazy-load for faster startup).
This provides commands like =M-x theme-to-pywal-generate-melpa-theme= for converting
newly installed themes.
#+begin_src emacs-lisp
;; Autoload theme conversion commands without loading the whole file
(autoload 'theme-to-pywal-generate-melpa-theme 
  (expand-file-name "~/.config/doom/theme-to-pywal.el")
  "Convert an installed Emacs theme to pywal JSON format." t)
(autoload 'theme-to-pywal-batch-generate-doom-themes
  (expand-file-name "~/.config/doom/theme-to-pywal.el")
  "Batch convert all Doom themes to pywal JSON presets." t)
#+end_src

* Org-Roam Configuration

My org-roam setup is designed for academic work, using a Zettelkasten-style
knowledge management system with concepts, lectures, readings, and projects.

** Org-Roam UI

Configure org-roam-ui for visual graph navigation of my knowledge base.
Note: org-roam-ui-sync-theme is disabled to prevent websocket port conflicts during
theme reloads, and to ensure better contrast in the web UI.
#+begin_src emacs-lisp
(use-package! org-roam-ui
  :after org-roam
  :hook (org-roam-mode . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme nil  ; Disabled to prevent port conflicts & ensure good contrast
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src

** Capture Templates

My capture templates support different types of content in my knowledge system:
- *Lectures* (=l=): Raw notes from lectures with post-processing checklist
- *Concepts* (=c=): Atomic concept nodes with definition, context, relations
- *Readings* (=rd=): Paper/book notes with citations
- *Recipes* (=r=): Recipe notes with ingredients and procedures
- *Assignments* (=a=): Coursework planning and tracking
- *Projects* (=p=): Personal project overviews
#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-v2-ack t)
  (setq org-roam-capture-templates
        '(("t" "Lecture quicknote" plain
           "%?\n* Post-Lecture Checklist\n- [ ] Extract definitions\n- [ ] Create/update concept node\n- [ ] Link readings\n- [ ] Mark processed"
           :if-new (file+head "academic/lectures/raw/%<%Y-%m-%d>-${slug}.org"
                              "#+TITLE: %<%Y-%m-%d> ${title} Lecture\n#+FILETAGS: :lecture:raw:\n")
           :unnarrowed t)
           ("c" "Concept node" plain
            "* Overview\n%?\n* Context\n* Relations\n* Applications\n* References"
            :if-new (file+head "concepts/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :concept:seed:\n")
            :unnarrowed t)
           ("rd" "Reading note" plain
            "* Summary\n%?\n* Key Claims\n* Methods\n* Critical Reflections\n* Links"
            :if-new (file+head "readings/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :reading:seed:\n:PROPERTIES:\n:ROAM_REFS: ${ref}\n:END:\n")
            :unnarrowed t)
           ("r" "Recipe" plain
            "* Ingredients\n\n- \n\n* Prep\n\n- \n\n* Procedure\n\n1. \n\n* Notes\n\n%?"
            :if-new (file+head "recipes/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :recipe:\n")
            :unnarrowed t)
          ("a" "Assignment plan" plain
           "* Brief\n%?\n* Requirements\n* Sources\n* Outline\n* Timeline\n* Status"
           :if-new (file+head "assignments/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :assignment:active:\n")
           :unnarrowed t)
           ("p" "Project node" plain
            "* Overview\n%?\n* Goals\n* Links\n* Decisions\n* TODO\n* Resources"
            :if-new (file+head "projects/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :project:active:\n")
            :unnarrowed t)))
  
  ;; Org-Roam Dailies Configuration
  (setq org-roam-dailies-directory "daily/")
  (setq org-roam-dailies-capture-templates
        '(("d" "Daily" entry
           "* <%<%Y-%m-%d %a %H:%M>>\n%?"
           :target (file+head "%<%Y-%m-%d>.org"
                              "#+TITLE: %<%B %d, %Y>\n#+FILETAGS: :daily:\n")))))
#+end_src

** Org-Roam Dailies

The dailies configuration is now integrated into the main org-roam configuration block above.

** Helper Functions

*** Promote Heading to Concept

This function extracts a heading from a lecture or inbox note and promotes it
to a standalone concept node. The heading's contents are copied into the new
concept file under the =* Overview= section, and a reference link to the original
heading is added to the concept's =* References= section. The original heading
is preserved (not deleted).
#+begin_src emacs-lisp
  (defun my/org-roam-promote-heading-to-concept ()
    "Promote current heading into a new concept node.
This:
- Creates `concepts/<slug>.org` (if missing) with a scaffold that uses '* Overview'.
- Copies the current heading's subtree (content below the heading line) into
  the new file under '* Overview' (appends).
- Transfers the original heading's ID to the new file (if it exists), so existing
  links to that heading automatically resolve to the new concept file.
- Removes the ID from the original heading to avoid duplicates.
- Inserts a link to the new concept in the original file's '* Relations' section as a bullet point.
It does NOT delete or replace the original heading." 
    (interactive)
    (unless (org-at-heading-p)
      (user-error "Not at a heading"))
    (let* ((title (nth 4 (org-heading-components)))
           (node (org-roam-node-create :title title))
           (slug (org-roam-node-slug node))
           (file (expand-file-name (format "concepts/%s.org" slug) org-roam-directory))
           ;; original subtree bounds
           (orig-beg (save-excursion (org-back-to-heading t) (point)))
           (orig-end (save-excursion (org-end-of-subtree t t)))
           ;; body = text after the heading line up to end of subtree
           (body (save-restriction
                   (widen)
                   (when (> orig-end orig-beg)
                     (save-excursion
                       (goto-char orig-beg)
                       (forward-line 1)
                       ;; Skip properties drawer if present
                       (when (looking-at "^[ \t]*:PROPERTIES:")
                         (when (re-search-forward "^[ \t]*:END:" orig-end t)
                           (forward-line 1)))
                       ;; Skip any blank lines after properties
                       (while (and (< (point) orig-end) (looking-at-p "^\\s-*$"))
                         (forward-line 1))
                       ;; Extract the actual content
                       (let ((content-start (point)))
                         (when (< content-start orig-end)
                           (string-trim (buffer-substring-no-properties content-start orig-end)))))))))
      ;; Ensure original heading has an ID so we can link to it later if needed
      (let ((orig-id (save-excursion
                       (org-back-to-heading t)
                       (or (org-entry-get nil "ID")
                           (org-id-get-create)))))
        ;; Create scaffold if file doesn't exist
        (unless (file-exists-p file)
          (with-temp-file file
            (insert ":PROPERTIES:\n:END:\n#+TITLE: " title "\n#+FILETAGS: :concept:seed:\n\n* Overview\n\n* Context\n* Relations\n* Applications\n* References\n")))
        ;; Transfer or create ID: use heading's existing ID if present, otherwise generate new one
        (let ((new-id (if orig-id
                          ;; Use the original heading's ID for the new file
                          (progn
                            (with-current-buffer (find-file-noselect file)
                              (goto-char (point-min))
                              (when (re-search-forward "^:PROPERTIES:" nil t)
                                (forward-line 1)
                                (insert (format ":ID: %s\n" orig-id)))
                              (save-buffer))
                            ;; Delete entire properties drawer from original heading
                            (save-excursion
                              (org-back-to-heading t)
                              (when (re-search-forward "^[ \t]*:PROPERTIES:" (save-excursion (outline-next-heading) (point)) t)
                                (let ((beg (line-beginning-position)))
                                  (when (re-search-forward "^[ \t]*:END:" (save-excursion (outline-next-heading) (point)) t)
                                    (delete-region beg (1+ (line-end-position)))))))
                            (save-buffer)
                            orig-id)
                        ;; No existing ID, generate a new one for the concept file
                        (let ((generated-id (org-id-new)))
                          (with-current-buffer (find-file-noselect file)
                            (goto-char (point-min))
                            (when (re-search-forward "^:PROPERTIES:" nil t)
                              (forward-line 1)
                              (insert (format ":ID: %s\n" generated-id)))
                            (save-buffer))
                          generated-id))))
          ;; Insert body into Overview if present
          (when (and body (not (string-empty-p (string-trim body))))
            (with-current-buffer (find-file-noselect file)
              (save-excursion
                (goto-char (point-min))
                (when (re-search-forward "^\\* Overview\\s-*$" nil t)
                  (forward-line 1)
                  ;; Clean up: remove any existing blank lines after Overview heading
                  (while (looking-at-p "^\\s-*$")
                    (delete-region (line-beginning-position) (1+ (line-end-position))))
                  ;; Insert the trimmed body content
                  (insert (string-trim body) "\n")
                  (save-buffer)))))
          ;; Insert a link to the NEW concept into the original file's *Relations section
          (save-excursion
            (goto-char (point-min))
            (if (re-search-forward "^\\* Relations\\s-*$" nil t)
                ;; Found Relations section, insert link
                (progn
                  (forward-line 1)
                  (insert (format "- [[id:%s][%s]]\n" new-id title))
                  (save-buffer))
              ;; No Relations section, create one at end of file
              (goto-char (point-max))
              (unless (bolp) (insert "\n"))
              (insert (format "* Relations\n- [[id:%s][%s]]\n" new-id title))
              (save-buffer)))
           (message "Promoted '%s' → %s (id:%s) and inserted link in original file" title file new-id)))))
#+end_src

*** Insert File Link

Insert a link to an external file (useful for linking to project files, GitHub repos, etc).
#+begin_src emacs-lisp
  (defun my/insert-file-link (path)
    "Insert an org file link to PATH with basename as description."
    (interactive "fFile: ")
    (insert (format "[[file:%s][%s]]" (abbreviate-file-name path) (file-name-base path))))
#+end_src

*** Add Heading ID

Add a UUID to a heading with a human-readable alias for easier referencing.
#+begin_src emacs-lisp
  (defun my/add-heading-id ()
    "Add org-id UUID to heading with filename-heading alias for org-roam."
    (interactive)
    (org-back-to-heading t)
    (let* ((filename (file-name-base (buffer-file-name)))
           (title (nth 4 (org-heading-components)))
           (alias (format "%s - %s" filename title))
           (id (org-id-get-create)))
      (org-set-property "ROAM_ALIASES" (format "\"%s\"" alias))
      (message "Added ID with alias: %s" alias)))
#+end_src

*** Insert Heading Link

Interactive function to pick an org file and heading, then insert a link with proper ID.
#+begin_src emacs-lisp
  (defun my/insert-heading-link ()
    "Pick an org file recursively, then link to a heading with org-id."
    (interactive)
    (let* ((current-buf (current-buffer))
           (brain2-dir (expand-file-name "~/Documents/brain2/"))
           (default-directory brain2-dir)
           ;; Get all org files recursively
           (org-files (directory-files-recursively brain2-dir "\\.org$"))
           ;; Make paths relative for cleaner display
           (file-choices (mapcar (lambda (f) (file-relative-name f brain2-dir)) org-files))
           (file-rel (completing-read "Org file: " file-choices nil t))
           (file (expand-file-name file-rel brain2-dir))
           (filename (file-name-base file)))
      (unless (file-exists-p file)
        (user-error "File not found: %s" file))
      ;; List headings in that file
      (with-current-buffer (find-file-noselect file)
        (let* ((headings (org-map-entries (lambda () (nth 4 (org-heading-components))) nil 'file))
               (heading (completing-read "Heading: " headings)))
          ;; Find the heading and get/create its ID
          (goto-char (point-min))
          (unless (search-forward heading nil t)
            (user-error "Heading not found: %s" heading))
          (org-back-to-heading t)
          (let* ((id (org-id-get-create))
                 (alias (format "%s - %s" filename heading))
                 (link (format "[[id:%s][%s]]" id heading)))
            ;; Ensure alias is set
            (unless (org-entry-get nil "ROAM_ALIASES")
              (org-set-property "ROAM_ALIASES" (format "\"%s\"" alias)))
            ;; Switch back to original buffer and insert link
            (with-current-buffer current-buf
              (insert link)
              (message "Inserted link: %s" link)))))))
#+end_src

** Smart Image Pasting

Smart paste function that handles both clipboard image data (screenshots) and file paths (Yazi workflow).
Automatically detects clipboard content type and routes to appropriate handler.
#+begin_src emacs-lisp
(defun my/org-smart-image-paste ()
  "Smart paste: handles clipboard image data and file:// URIs from Yazi.
Detects if clipboard contains:
- file:// URI (from Yazi) -> copy file to current heading's attachments (images, PDFs, etc)
- Image data (screenshot) -> use org-download at current heading
Works naturally with org-mode's heading-level attachment system.
Each heading gets its own attachment directory."
  (interactive)
  ;; Ensure we're in an org file
  (unless (derived-mode-p 'org-mode)
    (user-error "Must be in an org-mode buffer"))
  ;; Check that we're somewhere under a heading (don't move cursor!)
  (save-excursion
    (unless (ignore-errors (org-back-to-heading t))
      (user-error "Not in or under a heading")))
  (let* (;; Try to get clipboard text with timeout (2 seconds)
         (clipboard-text (condition-case nil
                            (with-timeout (2 nil)
                              (string-trim (shell-command-to-string 
                                           "timeout 2 xclip -o -selection clipboard -t UTF8_STRING 2>/dev/null")))
                          (error nil)))
         ;; Check if clipboard contains file:// URI from Yazi
         (is-file-uri (and clipboard-text
                          (not (string-empty-p clipboard-text))
                          (string-prefix-p "file://" clipboard-text)))
         ;; Extract actual file path from URI
         (filepath (when is-file-uri
                    (url-unhex-string (substring clipboard-text 7))))
         ;; Validate it's a file we want to attach (images, PDFs, markdown, etc)
         (is-valid-file (and filepath
                             (file-exists-p filepath)
                             (file-regular-p filepath)
                             (member (downcase (or (file-name-extension filepath) ""))
                                    '("png" "jpg" "jpeg" "gif" "webp" "bmp" "pdf" "md" "txt" "org")))))
    (cond
     ;; Yazi file:// URI workflow (images, PDFs, docs)
     (is-valid-file
      (my/attach-file-from-yazi filepath))
     ;; Screenshot workflow - try org-download with error handling
     (t
      (condition-case err
          (my/paste-screenshot-naturally)
        (error
         (user-error "No image found in clipboard. Please copy an image (screenshot) or file from Yazi first. Error: %s" 
                     (error-message-string err))))))))
(defun my/attach-file-from-yazi (filepath)
  "Attach file from Yazi to current heading using org-attach.
Handles images, PDFs, and documents. Creates heading ID and :ATTACH: tag if needed."
  (save-excursion
    ;; Ensure we're at the heading
    (org-back-to-heading t)
    (let* ((filename (file-name-nondirectory filepath))
           (timestamp (format-time-string "_%Y%m%d_%H%M%S"))
           (ext (file-name-extension filename))
           (base (file-name-sans-extension filename))
           (new-filename (format "%s%s.%s" base timestamp ext))
           (is-image (member (downcase ext) '("png" "jpg" "jpeg" "gif" "webp" "bmp"))))
      ;; Use org-attach to copy file (will create heading ID and :ATTACH: tag if needed)
      (org-attach-attach filepath nil 'cp)
      ;; Get the attachment directory and rename file to include timestamp
      (let* ((attach-dir (org-attach-dir))
             (old-path (expand-file-name filename attach-dir))
             (new-path (expand-file-name new-filename attach-dir)))
        (when (file-exists-p old-path)
          (rename-file old-path new-path t)))
      ;; Move to end of heading content to insert link
      (org-end-of-subtree t t)
      (unless (bolp) (insert "\n"))
      (insert (format "[[attachment:%s]]\n" new-filename))
      ;; Force refresh images if this was an image file
      (when is-image
        (org-remove-inline-images)
        (org-display-inline-images t t (point-min) (point-max)))
      (message "Attached from Yazi: %s (to heading: %s)" 
               new-filename 
               (org-get-heading t t t t)))))
(defun my/paste-screenshot-naturally ()
  "Paste screenshot at current heading by downloading from clipboard.
Creates heading ID and :ATTACH: tag if needed. Each heading gets its own directory.
Works similarly to Yazi paste but gets image data from clipboard."
  ;; Save current position FIRST before any movement
  (let ((original-point (point))
        heading-title
        attach-dir
        timestamp
        filename
        filepath)
    (message "DEBUG: Starting at point %d" original-point)
    ;; Do all the heading work in save-excursion so cursor doesn't move
    (save-excursion
      (org-back-to-heading t)
      (setq heading-title (org-get-heading t t t t))
      (message "DEBUG: Found heading '%s' at point %d" heading-title (point))
      ;; Ensure current heading has an ID
      (unless (org-id-get)
        (org-id-get-create))
      ;; Get attachment directory
      (setq attach-dir (org-attach-dir-get-create))
      (setq timestamp (format-time-string "%Y%m%d_%H%M%S"))
      (setq filename (format "_%sscreenshot.png" timestamp))
      (setq filepath (expand-file-name filename attach-dir))
      ;; Download clipboard image to file using xclip
      (with-timeout (5 (user-error "Clipboard access timed out. Try clearing your clipboard or taking a new screenshot."))
        (unless (= 0 (call-process "xclip" nil nil nil
                                  "-selection" "clipboard"
                                  "-t" "image/png"
                                  "-o"))
          (user-error "No image in clipboard or xclip failed")))
      ;; Save clipboard image to attachment directory
      (with-temp-buffer
        (set-buffer-multibyte nil)
        (call-process "xclip" nil t nil
                     "-selection" "clipboard"
                     "-t" "image/png"
                     "-o")
        (write-region (point-min) (point-max) filepath))
      (message "DEBUG: Saved screenshot to %s" filepath))
    ;; After save-excursion, we're back at original-point
    (message "DEBUG: Inserting link at point %d" (point))
    (unless (bolp) (insert "\n"))
    (insert (format "[[attachment:%s]]\n" filename))
    ;; Force refresh images
    (org-remove-inline-images)
    (org-display-inline-images t t (point-min) (point-max))
    (message "Screenshot pasted at point %d" (point))))
#+end_src

** Keybindings

All org-roam related keybindings are under the =SPC n= prefix.
#+begin_src emacs-lisp
  (map! :leader
        :desc "Promote heading to concept" "n P" #'my/org-roam-promote-heading-to-concept
        :desc "Insert file link" "n f" #'my/insert-file-link
        :desc "Add heading ID" "n i" #'my/add-heading-id
        :desc "Insert heading link" "n h" #'my/insert-heading-link
        :desc "Smart image paste (data/file)" "n p" #'my/org-smart-image-paste
        :desc "Find/create node" "n n" #'org-roam-node-find
        :desc "Insert node link" "n l" #'org-roam-node-insert
        :desc "Toggle backlinks" "n b" #'org-roam-buffer-toggle
        :desc "Open graph UI" "n g" #'org-roam-ui-open
        :desc "Capture new node" "n c" #'org-roam-capture)
#+end_src

** Buffer Navigation

Keybindings for cycling through buffers with Alt+Shift+H/L.
We need to unbind evil-org-mode's bindings which override the global ones.
#+begin_src emacs-lisp
;; Unbind evil-org-mode's M-H and M-L bindings
(after! evil-org
  (map! :map evil-org-mode-map
        :nvi "M-H" nil
        :nvi "M-L" nil))
;; Now set our buffer navigation bindings
(map! :nvi "M-H" #'previous-buffer
      :nvi "M-L" #'next-buffer)
#+end_src

* Lecture Processing

Helper function to mark a lecture as processed and move it from =raw/= to =processed/=.
#+begin_src emacs-lisp
(defun my/mark-lecture-processed ()
  "Mark current lecture note as processed and move to processed directory."
  (interactive)
  (let* ((file (buffer-file-name))
         (rel (file-relative-name file org-roam-directory)))
    (unless (string-match-p "academic/lectures/raw/" rel)
      (user-error "Not in raw lectures directory"))
    (save-excursion
      (goto-char (point-min))
      (unless (re-search-forward "POST-LECTURE CHECKLIST" nil t)
        (goto-char (point-max)))
      (save-buffer)
      (org-set-property "PROCESSED" (format-time-string "%Y-%m-%d")))
    (let* ((dest (expand-file-name (concat "academic/lectures/processed/" (file-name-nondirectory file)) org-roam-directory)))
      (rename-file file dest 1)
      (find-file dest)
      (message "Lecture processed & moved."))))
(map! :leader :desc "Process lecture" "n L" #'my/mark-lecture-processed)
#+end_src

* File Navigation

Use =consult-fd= for live, telescope-like file finding without caching.
#+begin_src emacs-lisp
;; SPC SPC - Find file in current project/directory (fast)
(map! :leader :desc "Find file (project)" "SPC" #'consult-fd)
;; SPC f f - Find file from home directory (fast, can type / for root)
(defun my/consult-fd-from-home ()
  "Find file using consult-fd starting from home directory."
  (interactive)
  (let ((default-directory "~")
        (projectile-require-project-root nil))
    (consult-fd)))
;; SPC f d - Find directory with consult-dir (built-in, fast)
(map! :leader
      :prefix "f"
      :desc "Find file from home" "f" #'my/consult-fd-from-home
      :desc "Find directory" "d" #'consult-dir)
#+end_src

** Performance: Fast Search Tools

Configure Emacs to use modern fast tools (fd, ripgrep) for all search operations.
#+begin_src emacs-lisp
;; Use fd instead of find for projectile
(after! projectile
  (when (executable-find "fd")
    (setq projectile-git-command "fd . -0 --type f --color=never"
          projectile-generic-command "fd . -0 --type f --color=never"
          projectile-indexing-method 'alien
          projectile-enable-caching nil)))  ; No cache needed with fd
;; Use ripgrep for project search
(after! counsel
  (when (executable-find "rg")
    (setq counsel-rg-base-command "rg --no-heading --line-number --color never %s .")))
;; Configure consult to use ripgrep and fd
(after! consult
  (when (executable-find "rg")
    (setq consult-ripgrep-args "rg --null --line-buffered --color=never --max-columns=1000 --path-separator / --smart-case --no-heading --with-filename --line-number --search-zip"))
  (when (executable-find "fd")
    (setq consult-fd-args "fd --color=never --full-path --hidden --exclude .git")))
;; Use ripgrep for Doom's default search
(after! vertico
  (when (executable-find "rg")
    (setq +default-want-RET-continue-p nil)))
#+end_src

** Yazi Integration (eee.el)

Launch yazi file manager in external terminal with Emacs integration.
#+begin_src emacs-lisp
(use-package! eee
  :config
  ;; Use suckless terminal for yazi and other TUI tools
  (setq ee-terminal-command "st")
  
  ;; Keybindings for yazi and other TUI tools
  (map! :leader
        :desc "Yazi (current dir)" "f y" #'ee-yazi
        :desc "Yazi (project)" "f Y" #'ee-yazi-project
        :desc "Ripgrep search" "s g" #'ee-rg
         :desc "Lazygit" "g z" #'ee-lazygit))
#+end_src

** Dired Configuration

Improve dired usability with better clipboard commands.
- Press ~y Y~ in dired to copy file itself to clipboard (for pasting into apps like Discord)
#+begin_src emacs-lisp
(after! dired
  (defun my/dired-copy-file-to-clipboard ()
    "Copy the file at point to system clipboard for pasting into applications."
    (interactive)
    (let ((file (dired-get-filename)))
      (if (file-directory-p file)
          (message "Cannot copy directory to clipboard")
        (let* ((mime-type (string-trim
                           (shell-command-to-string
                            (format "file --mime-type -b %s" (shell-quote-argument file)))))
               (cmd (format "xclip -selection clipboard -t %s -i %s"
                            mime-type
                            (shell-quote-argument file))))
          (call-process-shell-command cmd nil 0)
          (message "Copied file to clipboard: %s" (file-name-nondirectory file))))))
  
  (map! :map dired-mode-map
        :n "y Y" #'my/dired-copy-file-to-clipboard))
#+end_src

* Rust Configuration

Configure rust-analyzer to use the correct sysroot from rustup.
#+begin_src emacs-lisp
(after! rustic
  (setq lsp-rust-analyzer-server-display-inlay-hints t
        lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial"
        lsp-rust-analyzer-display-parameter-hints t
        lsp-rust-analyzer-display-closure-return-type-hints t))
(after! eglot
  ;; Set up environment for rust-analyzer
  (setenv "PATH" (concat (expand-file-name "~/.cargo/bin") ":" (getenv "PATH")))
  (setenv "RUSTUP_TOOLCHAIN" "stable-x86_64-unknown-linux-gnu")
  
  ;; Suppress EGLOT sentinel warnings for unresponsive servers
  ;; These warnings are harmless but noisy - we let EGLOT handle cleanup silently
  (setq eglot-extend-to-xref nil)
  (advice-add 'eglot--warn :around
    (lambda (orig-func &rest args)
      ;; Silence sentinel warnings about unresponsive servers
      (unless (and (> (length args) 0)
                   (stringp (car args))
                   (string-match "Sentinel for EGLOT.*still hasn't run" (car args)))
        (apply orig-func args))))
  
  (add-to-list 'eglot-server-programs
    '((rust-ts-mode rust-mode) .
      ("rust-analyzer" :initializationOptions
       (:checkOnSave t
        :procMacro (:enable t)
        :cargo (:buildScripts (:enable t)))))))
#+end_src

* Java Configuration

Configure eglot for Java with JDT LS and decompiled vendor sources.
Doom's java module doesn't auto-enable eglot when using =(lsp +eglot)=, so we add the hook manually.
#+begin_src emacs-lisp
;; Ensure eglot is loaded first
(use-package! eglot
  :defer t
  :config
  ;; Configure jdtls with better memory settings
  (add-to-list 'eglot-server-programs
               '((java-mode java-ts-mode) . 
                 ("jdtls"
                  "-Xmx2G"  ; Increase max heap to 2GB (default is too small)
                  "-Xms1G"  ; Start with 1GB heap
                  "--jvm-arg=-XX:+UseG1GC"  ; Use G1 garbage collector
                  "--jvm-arg=-XX:+UseStringDeduplication"))) ; Save memory
  
  ;; Performance: increase timeout for slow operations
  (setq eglot-sync-connect nil        ; Don't block Emacs waiting for server
        eglot-connect-timeout 60      ; Allow 60s for initial connection
        eglot-autoshutdown t          ; Shutdown server when last buffer closes
        eglot-send-changes-idle-time 0.5) ; Send changes after 0.5s idle
  
  ;; Enable hover documentation (eldoc)
  (add-hook 'eglot-managed-mode-hook
            (lambda ()
              (when (derived-mode-p 'java-mode)
                ;; Enable eldoc for hover info (Shift-K)
                (setq eldoc-echo-area-use-multiline-p t)
                (eldoc-mode 1)))))

;; Add hook to auto-start eglot in java-mode
(add-hook 'java-mode-hook #'eglot-ensure)

;; eldoc-box: floating child frame popup for hover docs (VS Code-style Shift-K)
(use-package! eldoc-box
  :config
  (setq eldoc-box-max-pixel-width 600
        eldoc-box-max-pixel-height 400
        eldoc-box-clear-with-C-g t
        eldoc-box-cleanup-interval 0.5))

;; Override Doom's +eglot-lookup-documentation with a toggle:
;; - First K  → floating eldoc-box child frame
;; - Second K → dismiss frame, open the classic *eglot-help* split (Doom's
;;              original behaviour, with q to quit and full scrollability)
;; A flag variable tracks whether the box was open so we don't rely on
;; frame-visible-p (which is already nil by the time the command runs again).
(after! (eglot eldoc-box)
  (defvar +eglot--help-box-was-open nil
    "Non-nil when eldoc-box child frame was shown on last K press.")

  (defun +eglot-lookup-documentation (_identifier)
    "Show hover docs via eldoc-box. Press K again to open the classic help split."
    (if +eglot--help-box-was-open
        (progn
          (setq +eglot--help-box-was-open nil)
          ;; Call Doom's original implementation directly by looking up the
          ;; hover info ourselves, same as the original +eglot-lookup-documentation.
          (eglot--dbind ((Hover) contents range)
              (jsonrpc-request (eglot--current-server-or-lose) :textDocument/hover
                               (eglot--TextDocumentPositionParams))
            (let ((blurb (and (not (seq-empty-p contents))
                              (eglot--hover-info contents range)))
                  (hint (thing-at-point 'symbol)))
              (if blurb
                  (with-current-buffer
                      (or (and (buffer-live-p +eglot--help-buffer)
                               +eglot--help-buffer)
                          (setq +eglot--help-buffer (generate-new-buffer "*eglot-help*")))
                    (with-help-window (current-buffer)
                      (rename-buffer (format "*eglot-help for %s*" hint))
                      (with-current-buffer standard-output (insert blurb))
                      (setq-local nobreak-char-display nil)))
                (display-local-help))))
          'deferred)
      (setq +eglot--help-box-was-open t)
      ;; Reset flag whenever the frame is dismissed by any means (C-g, cursor move, etc.)
      (advice-add 'eldoc-box-quit-frame :after
                  (lambda (&rest _) (setq +eglot--help-box-was-open nil))
                  '((name . +eglot--reset-box-flag)))
      (eldoc-box-help-at-point)
      t)))
#+end_src

* AI Integration: Copilot

Real-time code completion using GitHub Copilot.
Copilot is NOT started automatically - toggle it per-buffer with =SPC o l t=.
#+begin_src emacs-lisp
(use-package! copilot
  :commands (copilot-mode copilot-toggle)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)
              ("M-f" . 'copilot-accept-completion-by-word)
              ("M-n" . 'copilot-next-completion)
              ("M-p" . 'copilot-previous-completion))
  :config
  (setq copilot-indent-offset-alist '((prog-mode . 2)
                                      (org-mode . 2)
                                      (emacs-lisp-mode . 2)
                                      (python-mode . 4)
                                      (rust-mode . 4)))
  
  ;; Silence copilot indentation warning for non-programming modes
  (defun copilot--infer-indentation-offset ()
    "Infer indentation offset, silently return nil if no standard indent found."
    (let ((indent-size
           (or (and (eq major-mode 'python-mode) 4)
               (and (eq major-mode 'rust-mode) 4)
               (and (eq major-mode 'go-mode) 8)
               (and (eq major-mode 'c++-mode) 2)
               (and (eq major-mode 'c-mode) 2)
               (and (eq major-mode 'java-mode) 4)
               (and (eq major-mode 'js-mode) 2)
               (and (eq major-mode 'typescript-mode) 2)
               (and (eq major-mode 'emacs-lisp-mode) 2)
               (and (eq major-mode 'lisp-mode) 2)
               (and (eq major-mode 'scheme-mode) 2)
               (and (eq major-mode 'clojure-mode) 2)
               (and (eq major-mode 'ruby-mode) 2)
               2))) ; Default to 2 without warning
      indent-size))
  
  ;; Custom TAB handler for Evil insert state
  (defun my/copilot-tab-or-default ()
    (interactive)
    (cond
     ((and (bound-and-true-p copilot-mode)
           (copilot--overlay-visible-p))
      (copilot-accept-completion))
     ((and (featurep 'corfu)
           corfu--visible)
      (corfu-next))
     (t
      (insert "\t"))))
  (after! evil
    (evil-define-key 'insert 'global (kbd "<tab>") #'my/copilot-tab-or-default)
    (evil-define-key 'insert 'global (kbd "TAB") #'my/copilot-tab-or-default)))

;; Keybinding to toggle copilot (similar to gptel workflow)
(map! :leader
      :desc "Toggle Copilot" "o l t" #'copilot-mode)
#+end_src
#+end_src

* AI Integration: GPTel

GPTel provides AI assistance directly in Emacs with multiple presets optimized for different workflows.

** Core Configuration

#+begin_src emacs-lisp
(use-package! gptel
  :config
  ;; Default to Haiku for quick queries
  (setq gptel-model 'claude-haiku-4.5
        gptel-backend (gptel-make-gh-copilot "Copilot")
        gptel-default-mode 'org-mode)
  
  ;; Helper function for dynamic context (project, file, buffer info)
  (defun my/gptel-dynamic-context ()
    "Generate dynamic context string for gptel prompts."
    (let* ((project (and (fboundp 'projectile-project-name) 
                        (projectile-project-name)))
           (file (buffer-file-name))
           (mode major-mode)
           (in-brain2 (and file (string-match-p "Documents/brain2" file)))
           (in-doom-config (and file (string-match-p "\\.config/doom" file)))
           (in-dwm-config (and file (string-match-p "Documents/brain2/concepts/dwm\\.org" file))))
      (concat
       ;; Base environment
       "You are in Doom Emacs on Arch Linux with DWM window manager. "
       
       ;; Current context
       (when project
         (format "Current project: %s. " project))
       (when file
         (format "Current file: %s. " (file-name-nondirectory file)))
       (format "Major mode: %s. " mode)
       
       ;; Specific workspace context
       (cond
        (in-dwm-config
         "This is the literate DWM config (dwm.org) which tangles to ~/.local/src/dwm/config.h. ")
        (in-doom-config
         "This is Doom Emacs config directory. Literate configs (.org files) tangle to .el files. ")
        (in-brain2
         "This is my org-roam PKM for psychology studies. Inbox.org contains todos and agenda info. Understand concept nodes, lecture notes, and org-roam links. "))
       
       "\n\n")))
  
  ;; Tool safety: require confirmation for destructive operations
  (setq gptel-confirm-tool-calls '(write edit bash))
  
  ;; Presets for different workflows
  
  ;; 1. CODING - Sonnet 4.5 with full agent capabilities
  (gptel-make-preset 'coding
    :description "Coding assistant with full tool access (Sonnet 4.5)"
    :backend "Copilot"
    :model 'claude-sonnet-4.5
    :system (lambda () 
              (concat 
               (my/gptel-dynamic-context)
               "You are an expert coding assistant in Emacs. You have access to tools for reading files (including ~/Documents/brain2/ for notes/todos), searching code, running tests, and making edits. Always confirm before modifying code. Provide concise, actionable suggestions. When writing code, follow the project's existing style and patterns."))
    :stream t
    :temperature 0.3
    :use-context 'system
    :use-tools t)
  
  ;; 2. WRITING - GPT 5-mini for PKM work (lightweight, context-aware)
  (gptel-make-preset 'writing
    :description "Writing assistant for org-roam PKM (GPT 5-mini)"
    :backend "Copilot"
    :model 'gpt-5-mini
    :system (lambda ()
              (concat
               (my/gptel-dynamic-context)
               "You are a writing assistant for academic work in psychology. You're operating within an org-roam PKM system at ~/Documents/brain2/. Understand concept nodes, lecture notes, and the Zettelkasten method. Help with writing, clarifying ideas, and organizing knowledge. You have read tool access for referencing notes when needed. You should not create links, new nodes, or manage todos autonomously - that's handled by a different preset. Focus on writing, ideas, and academic content. Respond concisely and academically."))
    :stream t
    :temperature 0.7
    :use-context 'system
    :use-tools t)
  
  ;; 3. CONFIGURING - Sonnet 4.5 for system/Emacs configuration
  (gptel-make-preset 'configuring
    :description "Config assistant for DWM/Doom/system configs (Sonnet 4.5)"
    :backend "Copilot"
    :model 'claude-sonnet-4.5
    :system (lambda ()
              (concat
               (my/gptel-dynamic-context)
               "You are a system configuration expert for Arch Linux, DWM, and Doom Emacs. You understand:\n"
               "- Literate programming with org-babel (edit .org files, not generated files)\n"
               "- DWM configuration: dwm.org tangles to ~/.local/src/dwm/config.h\n"
               "- Doom Emacs: config.org tangles to config.el\n"
               "- The user will run org-babel-tangle themselves after edits\n"
               "- DWMBlocks in ~/dotfiles/dwmblocks/\n"
               "- Scripts in ~/dotfiles/scripts/.config/scripts/\n"
               "- Pywal theming system with 120+ presets\n\n"
               "You have full tool access including reading files anywhere (~/Documents/brain2/ for notes, config files, etc). Provide configuration suggestions that work with this literate setup. Always edit .org source files, not generated files. Explain the changes clearly."))
    :stream t
    :temperature 0.3
    :use-context 'system
    :use-tools t)
  
  ;; 4. QUICK - GPT 4.1 for task management and quick actions
  (gptel-make-preset 'quick
    :description "Fast task manager for todos/scheduling (GPT 4.1)"
    :backend "Copilot"
    :model 'gpt-4.1
    :system (lambda ()
              (concat
               (my/gptel-dynamic-context)
               "You are a fast, proactive task management assistant. Your job is to execute user requests with minimal back-and-forth. Key behaviors:\n\n"
               "- **Inbox location**: ~/Documents/brain2/inbox.org\n"
               "- **Read files silently**: When asked about todos, scheduling, or tasks, read Inbox.org immediately without asking\n"
               "- **Infer intent**: If asked to 'schedule a todo', read the inbox, determine the right section (like 'This Week'), and write the entry there\n"
               "- **Org format**: Use proper org syntax: '* TODO Title' with 'SCHEDULED: <YYYY-MM-DD Dow HH:MM>' for scheduled items\n"
               "- **Be direct**: Just do it. Don't propose options unless genuinely unclear\n"
               "- **Understand context**: If the user is in brain2, you're managing their life/psychology study todos. Act accordingly.\n\n"
               "You have full read/write access. Use it. Get things done efficiently."))
    :stream t
    :temperature 0.4
    :use-context 'system
    :use-tools t)
  
  ;; Legacy preset (kept for compatibility)
  (gptel-make-preset 'brain2beta
    :description "[Legacy] Org-roam PKM assistant"
    :backend "Copilot"
    :model 'gpt-4.1
    :system "You are a large language model living in my DOOM Emacs and a helpful assistant. We are currently operating within my org-roam based PKM at ~/Documents/brain2/, which I am learning to use to manage my life studying psychology and my interests. You have access to read tools - use them to read Inbox.org for todos or any other notes when needed. Respond concisely."
    :stream t
    :temperature 1.0
    :include-reasoning t
    :use-context 'system
    :use-tools t))
;; Configure gptel-quick (explain/summarize) to use gpt-4.1
(after! gptel-quick
  (setq gptel-quick-backend (gptel-make-gh-copilot "Copilot")
        gptel-quick-model 'gpt-4.1))
;; Configure gptel-magit to use gpt-4.1 with conventional commits
(after! gptel-magit
  (setq gptel-magit-backend (gptel-make-gh-copilot "Copilot")
        gptel-magit-model 'gpt-4.1
        ;; Custom prompt emphasizing brevity for personal repos
        gptel-magit-commit-prompt
        "You are an expert at writing Git commits. Write a short, clear commit message using conventional commits format.
CRITICAL: The subject line MUST be under 50 characters. Be extremely concise.
Format:
    <type>: <concise description>
    
    [optional body if needed]
Types: feat, fix, docs, style, refactor, test, chore
Only add scope like `feat(scope):` when absolutely necessary. For personal repos with broad changes, omit the scope.
Keep it SHORT. Examples of good length:
- feat: add auth system
- fix: handle null in parser
- docs: update readme
- refactor: simplify error handling
If the change affects multiple files/areas in a personal backup repo, use a general description without scope.
Only return the commit message. No meta-commentary."))
;; Helper functions to quickly switch presets and open gptel
(defun my/gptel-coding ()
  "Open gptel with coding preset."
  (interactive)
  (let ((buf (gptel "*gptel-coding*")))
    (switch-to-buffer buf)
    (gptel--apply-preset 'coding (lambda (sym val) (set (make-local-variable sym) val)))))
(defun my/gptel-writing ()
  "Open gptel with writing preset."
  (interactive)
  (let ((buf (gptel "*gptel-writing*")))
    (switch-to-buffer buf)
    (gptel--apply-preset 'writing (lambda (sym val) (set (make-local-variable sym) val)))))
(defun my/gptel-configuring ()
  "Open gptel with configuring preset."
  (interactive)
  (let ((buf (gptel "*gptel-config*")))
    (switch-to-buffer buf)
    (gptel--apply-preset 'configuring (lambda (sym val) (set (make-local-variable sym) val)))))
(defun my/gptel-quick ()
  "Open gptel with quick preset."
  (interactive)
  (let ((buf (gptel "*gptel-quick*")))
    (switch-to-buffer buf)
    (gptel--apply-preset 'quick (lambda (sym val) (set (make-local-variable sym) val)))))
;; Keybindings for preset switching (under SPC o l prefix)
;; Don't redefine the prefix, just add to it
(map! :leader
      :desc "Coding (Sonnet)" "o l C" #'my/gptel-coding
      :desc "Writing (5-mini)" "o l w" #'my/gptel-writing
      :desc "Config (Sonnet)" "o l g" #'my/gptel-configuring
      :desc "Quick (Haiku)" "o l q" #'my/gptel-quick)
#+end_src

** GPTel Agent

GPTel Agent extends gptel with autonomous agent capabilities - the LLM can take actions,
browse the web, read/write files, and execute code. Requires gptel to be up to date.
The agent preset is already integrated into the presets above. Each preset has tools configured:
- *Coding*: Full tool access with confirmation for writes/edits
- *Writing*: Read tools for searching PKM, confirmation for writes
- *Configuring*: Full tool access for config files
- *Quick*: Full tool access for task management
First, load gptel-agent to register tools:
#+begin_src emacs-lisp
(use-package! gptel-agent
  :after gptel
  :commands (gptel-agent)
  :init
  ;; Load tools early so they're available for gptel presets
  (with-eval-after-load 'gptel
    (require 'gptel-agent-tools)
    ;; Set gptel-tools after tools are registered
    (setq gptel-tools (gptel-get-tool "gptel-agent")))
  :config
  ;; Initialize agent tools and capabilities
  (gptel-agent-update))
#+end_src

** Usage Guide

*** Keybindings (SPC o l prefix)

- =SPC o l l= -- Open gptel (default: quick preset)
- =SPC o l m= -- Open gptel menu (switch models/presets)
- =SPC o l c= -- Open gptel-agent (autonomous mode)
- =SPC o l e= -- Explain selected text
- =SPC o l a= -- Add text to context
- =SPC o l f= -- Add file to context

*** Quick Preset Switching (NEW)

- =SPC o l C= -- Switch to Coding preset (Sonnet 3.5)
- =SPC o l w= -- Switch to Writing preset (GPT 5-mini)
- =SPC o l g= -- Switch to Config preset (Sonnet 3.5)
- =SPC o l q= -- Switch to Quick preset (Haiku 3.5)

*** Workflow Tips

1. *Coding*: Use for code review, debugging, refactoring. Tools enabled for reading files and running tests.
2. *Writing*: Use in org-roam for drafting, clarifying concepts, academic writing. Can search your PKM for context.
3. *Configuring*: Use for system configs, DWM, Doom Emacs. Understands literate programming and tangling.
4. *Quick*: Use for fast explanations, definitions, quick questions. No tool overhead.
5. *Magit Integration*: AI-powered commit messages and diff explanations
   - In magit commit menu: Press =c g= to generate conventional commit message
   - In commit buffer: Press =M-g= to generate message
   - In magit diff menu: Press =d x= to explain diff in plain language
   - Uses GPT-4.1 with conventional commits format (feat/fix/docs/refactor/etc)

*** Tool Safety

- Read operations (search, file reading, web fetch): Auto-approved
- Write operations (file edits, bash commands): Require confirmation
- Configure via =gptel-confirm-tool-calls= variable

* Discord Presence

Show your Emacs activity on Discord using emacs-rpc.
Lazy-loaded to avoid startup overhead.
#+begin_src emacs-lisp
(use-package! presence
  :defer 5  ; Load 5 seconds after startup (lazy-load for performance)
  :commands (presence-mode)
  :init
  ;; Don't auto-enable, let it load lazily
  (run-with-idle-timer 5 nil #'presence-mode)
  :config
  ;; Use custom Discord application
  (setq presence-client-id "1443438985878962228")
  ;; Use asset keys directly (not URLs) for our custom Discord app
  (setq presence-icon-base nil)
  ;; Override to return just the asset key
  (defun presence--resolve-icon-base (icon)
    "Return just the icon asset key for Discord."
    icon)
  ;; Use custom icon from our Discord app
  (setq presence-editor-icon "emacs-icon")
  ;; Keep editor as main icon, mode as small icon
  (setq presence-use-major-mode-as-main-icon nil)
  ;; Show the small icon (mode icon)
  (setq presence-show-small-icon t)
  ;; Add extra mode icon mappings
  (setq presence-mode-icon-alist
        (append '((magit-status-mode . "git")
                  (magit-log-mode . "git")
                  (magit-diff-mode . "git")
                  (magit-revision-mode . "git")
                  (conf-toml-mode . "toml"))
                presence-mode-icon-alist))
  ;; Hide line numbers from status
  (setq presence-display-line-numbers nil)
  ;; Custom format: show project name + file instead of just buffer name
  (defun my/presence-buffer-details ()
    (let ((project (projectile-project-name))
          (file (buffer-name)))
      (if (and project (not (string= project "-")))
          (format "In %s: %s" project file)
        (format "Editing %s" file))))
  (setq presence-buffer-details-format-function #'my/presence-buffer-details))
#+end_src

* Org-Todo

Configure todo keywords for different task types.
#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords
        '((sequence "TODO(t)" "PROJ(p)" "LOOP(l)" "SKILL(s)" "|" "DONE(d)" "KILL(k)")))
  
  ;; Add CLOSED timestamp when marking TODO as DONE
  (setq org-log-done 'time)
  
  ;; Explicitly set DONE as the primary completion state
  ;; This ensures C-c C-t cycles to DONE first, not KILL
  (setq org-todo-repeat-to-state "TODO")
  
  ;; Configure logging for state changes
  (setq org-log-redeadline 'time
        org-log-reschedule 'time)
  
  ;; Use fast todo selection with single key press
  (setq org-use-fast-todo-selection t))
 #+end_src

* Org Agenda

Single-page agenda overview tuned to my `inbox.org` workflow.
#+begin_src emacs-lisp
(setq org-agenda-start-with-log-mode t)
(after! org-agenda
  (setq org-agenda-files '("~/Documents/brain2/")
        org-hide-emphasis-markers t
        org-agenda-compact-blocks t
        org-agenda-block-separator ?─)
  ;; Use nerd-icons for priority symbols if you want (commented out by default)
  ;; (setq org-priority-highest ?A
  ;;       org-priority-lowest ?C
  ;;       org-priority-default ?B)
  ;; Use Doom's default Evil behavior in Agenda (motion state).
  ;; `evil-org-agenda` defines most of Doom's agenda-friendly bindings in
  ;; motion state; forcing `normal` makes keys like `q` fall back to Evil's
  ;; macro recording.
  (set-evil-initial-state! 'org-agenda-mode 'motion)
  ;; Some agenda views (e.g. `alltodo`, often used for overview dashboards)
  ;; can end up using Org's default `org-agenda-mode-map` bindings.
  ;; Ensure `j/k` always move by line (Doom-style).
  (define-key org-agenda-mode-map (kbd "j") #'org-agenda-next-line)
  (define-key org-agenda-mode-map (kbd "k") #'org-agenda-previous-line)
  ;; Fallback: ensure emphasis markers are hidden when org-mode starts
  (add-hook 'org-mode-hook (lambda () (setq org-hide-emphasis-markers t)))
  ;; Custom agenda commands
  (setq org-agenda-custom-commands
        '(("o" "Overview"
           alltodo ""
           ((org-agenda-overriding-header "Active Tasks")
            (org-agenda-skip-function
             (lambda ()
               (let ((file (buffer-file-name)))
                 ;; Skip items in Archive section
                 (when (save-excursion
                         (org-back-to-heading t)
                         (let ((path (org-get-outline-path)))
                           (member "Archive" path)))
                   (org-end-of-subtree t)))))
            (org-super-agenda-groups
             '((:name "Overdue" :deadline past :order 1)
               (:name "Today" :scheduled today :deadline today :order 2)
               (:name "This Week"
                :pred (lambda (item)
                        (org-super-agenda--when-with-marker-buffer (org-super-agenda--get-marker item)
                          (let ((sched (org-entry-get (point) "SCHEDULED"))
                                (dead (org-entry-get (point) "DEADLINE")))
                            (or (and sched
                                     (let ((sched-abs (org-time-string-to-absolute sched)))
                                       (and (> sched-abs (org-today))
                                            (< sched-abs (+ (org-today) 7)))))
                                (and dead
                                     (let ((dead-abs (org-time-string-to-absolute dead)))
                                       (and (> dead-abs (org-today))
                                            (< dead-abs (+ (org-today) 7)))))))))
                :order 3)
               (:name "High Priority (A)" :priority "A" :order 4)
               (:name "Medium Priority (B)" :priority "B" :order 5)
               (:name "Projects" :todo "PROJ" :order 6)
               (:name "Recurring" :todo "LOOP" :order 7)
               (:name "Unscheduled TODOs" :and (:todo "TODO" :not (:scheduled t :deadline t)) :order 8)
               (:discard (:todo ("DONE" "KILL")))))))
           ("t" "Today"
            agenda ""
            ((org-agenda-span 'day)
             (org-deadline-warning-days 0)
             (org-agenda-start-with-log-mode nil)
             (org-agenda-skip-function
              (lambda ()
                (when (member (org-get-todo-state) '("DONE" "KILL"))
                  (org-end-of-subtree t))))
            (org-super-agenda-groups
             '((:name "Scheduled Today" :scheduled today :order 1)
               (:name "Due Today" :deadline today :order 2)
               (:name "Overdue" :deadline past :order 3)
               (:discard (:todo ("DONE" "KILL")))))))
           ("w" "This Week"
            agenda ""
            ((org-agenda-span 7)
             (org-deadline-warning-days 0)
             (org-agenda-start-with-log-mode nil)
             (org-agenda-skip-function
              (lambda ()
                (when (member (org-get-todo-state) '("DONE" "KILL"))
                  (org-end-of-subtree t))))
            (org-super-agenda-groups
             '((:name "Overdue" :deadline past :order 1)
               (:name "Today" :scheduled today :deadline today :order 2)
               (:name "This Week" :scheduled (next 7 days) :deadline (next 7 days) :order 3)
               (:discard (:todo ("DONE" "KILL"))))))))))
(use-package! org-super-agenda
  :after org-agenda
  :config
  ;; `org-super-agenda` applies a separate keymap to group headers.
  ;; Ensure it stays in sync with the agenda buffer's map so `j/k`
  ;; behave the same on headers and items.
  (setq org-super-agenda-header-map org-agenda-mode-map
        org-super-agenda-header-prefix "  "
        org-super-agenda-header-separator "")
  (org-super-agenda-mode 1))
(defun my/org-agenda-skip-unless-top-level (top-level-heading)
  "Skip entry unless it is under TOP-LEVEL-HEADING."
  (let ((path (ignore-errors (org-get-outline-path t t))))
     (unless (and (consp path) (string= (car path) top-level-heading))
       (or (outline-next-heading) (point-max)))))
#+end_src

* Google Calendar Integration

Configure org-gcal to sync org-mode events with Google Calendar.
This setup prioritizes *pushing* events TO Google Calendar from org-mode.
Doom already provides calfw integration, we just need to configure org-gcal.

** Setup Instructions

1. Create Google Cloud Project and OAuth credentials:
   - Go to https://console.cloud.google.com/
   - Create a new project (or use existing)
   - Enable Google Calendar API
   - Create OAuth 2.0 credentials (Desktop app)
   - Download the JSON credentials
2. Store your credentials securely:
   - Credentials stored in =~/.config/doom/.secrets/gcal-oauth.el= (not in git)
   - Token will be stored in =~/.config/doom/.local/org-gcal/=

** Configuration

Load credentials early (before org-gcal loads):
#+begin_src emacs-lisp
;; Load Google Calendar OAuth credentials BEFORE org-gcal initializes
;; This prevents "must set client-id and client-secret" errors on fresh restart
(let ((secrets-file (expand-file-name "~/.config/doom/.secrets/gcal-oauth.el")))
  (when (file-exists-p secrets-file)
    (load secrets-file)))
#+end_src
Configure org-gcal with push-only mode:
#+begin_src emacs-lisp
(after! org-gcal
  ;; Set local timezone for proper time conversion (CRITICAL!)
  (setq org-gcal-local-timezone "Europe/London")
  
  ;; Set calendar location for Emacs calendar
  (setq calendar-location-name "London, UK"
        calendar-latitude 51.5
        calendar-longitude -0.1
        calendar-time-zone 0           ; GMT offset (0 minutes)
        calendar-standard-time-zone-name "GMT"
        calendar-daylight-time-zone-name "BST")
  
  ;; Map inbox.org to Google Calendar - sync scheduled/deadline events
  (setq org-gcal-fetch-file-alist '(("hugo.serranochan@gmail.com" . "~/Documents/brain2/inbox.org"))
        org-gcal-auto-local-sync t)
  
  ;; Wrapper that auto-sets calendar-id before posting (avoids prompt)
  (defun my/org-gcal-post-with-calendar-id ()
    "Post entry to Google Calendar, auto-setting calendar-id if missing."
    (interactive)
    (save-excursion
      (org-back-to-heading t)
      ;; Auto-add calendar-id property if missing
      (unless (org-entry-get (point) "calendar-id")
        (org-entry-put (point) "calendar-id" "hugo.serranochan@gmail.com"))
      ;; Now post the event
      (org-gcal-post-at-point)))
  
  ;; Auto-sync hooks: Push to Google Calendar on save/capture
  (add-hook 'org-capture-after-finalize-hook 'org-gcal-sync)
  (add-hook 'org-archive-hook 'org-gcal-sync))
#+end_src
Keybindings for calendar operations (always available, autoload org-gcal when used):
#+begin_src emacs-lisp
(map! :leader
      :prefix "o"
      :desc "Open calendar view" "c" #'+calendar/open-calendar
      :desc "Fetch from Google Calendar" "g f" #'org-gcal-fetch
      :desc "Post event to Calendar" "g p" (cmd! (require 'org-gcal) (my/org-gcal-post-with-calendar-id))
      :desc "Delete Calendar event" "g d" (cmd! (require 'org-gcal) (org-gcal-delete-at-point)))
#+end_src

** Calfw Theme Integration

Make calfw match your Doom theme for better readability:
#+begin_src emacs-lisp
(after! calfw
  ;; Theme-aware faces for better readability with pywal/doom themes
  (custom-set-faces!
   ;; Main calendar title
   '(calfw-title-face :inherit font-lock-keyword-face :height 1.5 :weight bold)
   
   ;; Header (day names)
   '(calfw-header-face :inherit font-lock-function-name-face :weight bold)
   
   ;; Date grid
   '(calfw-grid-face :inherit shadow)
   
   ;; Today's date highlight
   '(calfw-today-face :background nil :foreground nil :weight bold 
     :inherit (highlight font-lock-constant-face))
   
   ;; Default day titles
   '(calfw-day-title-face :inherit default)
   
   ;; Sunday
   '(calfw-sunday-face :inherit font-lock-warning-face :weight bold)
   
   ;; Saturday
   '(calfw-saturday-face :inherit font-lock-type-face :weight bold)
   
   ;; Events/content
   '(calfw-default-content-face :inherit font-lock-string-face)
   
   ;; Multi-day events
   '(calfw-periods-face :inherit font-lock-keyword-face :slant italic)
   
   ;; Selected date (note: calfw doesn't have a select face, using today-title instead)
   '(calfw-today-title-face :background nil :inherit region :weight bold)
   
   ;; Holidays
   '(calfw-holiday-face :inherit font-lock-warning-face)
   
   ;; Toolbar
   '(calfw-toolbar-face :inherit mode-line)
   '(calfw-toolbar-button-off-face :inherit mode-line-inactive)
   '(calfw-toolbar-button-on-face :inherit mode-line :weight bold)))
#+end_src

** Usage

- Create events in org-mode with timestamps: =SCHEDULED: <2025-01-15 Wed 14:00-15:00>=
- Save the file → automatically syncs to Google Calendar
- View calendar: =SPC o c=
- Manual sync: =SPC o g s=
- Post single event: =SPC o g p= (with cursor on event)
- Delete event: =SPC o g d= (removes from both org and Google Calendar)

* Org-Pomodoro Configuration

Configure org-pomodoro for the Pomodoro technique with manual break support.
The manual-break feature allows you to work a few minutes "overtime" to finish a task
before manually triggering the break by calling ~org-pomodoro~ again.
Notifications are sent via dunst (libnotify): one when entering overtime, one when break finishes.
#+begin_src emacs-lisp
;; Ensure DBUS session bus is set for notifications to work
(unless (getenv "DBUS_SESSION_BUS_ADDRESS")
  (let ((dbus-addr (format "unix:path=/run/user/%d/bus" (user-uid))))
    (when (file-exists-p (substring dbus-addr 10))
      (setenv "DBUS_SESSION_BUS_ADDRESS" dbus-addr))))
(use-package! alert
  :config
  ;; Configure alert to use libnotify (dunst) for org-pomodoro notifications
  (setq alert-default-style 'libnotify))
(use-package! org-pomodoro
  :after org
  :config
  ;; Enable manual break workflow: break won't auto-start, you control when it begins
  (setq org-pomodoro-manual-break t
        
        ;; Disable all sounds - use notifications only
        org-pomodoro-play-sounds nil
        org-pomodoro-start-sound-p nil
        org-pomodoro-finished-sound-p nil
        org-pomodoro-overtime-sound-p nil
        org-pomodoro-short-break-sound-p nil
        org-pomodoro-long-break-sound-p nil
        org-pomodoro-ticking-sound-p nil
        
        ;; Only clock work time, not breaks
        org-pomodoro-clock-break nil
        
        ;; Pomodoro and break durations (customize as needed)
        org-pomodoro-length 25
        org-pomodoro-short-break-length 5
        org-pomodoro-long-break-length 20
        org-pomodoro-long-break-frequency 4)
  
  ;; Override org-pomodoro-notify to disable built-in notifications
  ;; (we handle notifications via hooks instead)
  (defun org-pomodoro-notify (title message)
    "Disabled - we use custom hooks for notifications instead."
    nil)
  
  ;; Notification when entering overtime
  (defun my/org-pomodoro-overtime-notify ()
    "Send notification when overtime starts."
    (alert "Finished, overtime started" :title "Pomodoro" :category 'org-pomodoro))
  
  ;; Notification when breaks finish
  (defun my/org-pomodoro-short-break-finished-notify ()
    "Send notification when short break finishes."
    (alert "Short break finished" :title "Pomodoro" :category 'org-pomodoro))
  
  (defun my/org-pomodoro-long-break-finished-notify ()
    "Send notification when long break finishes."
    (alert "Long break finished" :title "Pomodoro" :category 'org-pomodoro))
  
  ;; Hook notifications into org-pomodoro events (only specific hooks to avoid duplicates)
  (add-hook 'org-pomodoro-overtime-hook
    (lambda () (my/org-pomodoro-overtime-notify)))
  
  (add-hook 'org-pomodoro-short-break-finished-hook
    (lambda () (my/org-pomodoro-short-break-finished-notify)))
  
  (add-hook 'org-pomodoro-long-break-finished-hook
    (lambda () (my/org-pomodoro-long-break-finished-notify)))
  
  ;; Keybinding for quick pomodoro access
  (map! :leader
        :desc "Start/stop pomodoro" "o p" #'org-pomodoro))
#+end_src

* Org Formatting

Simple, clean formatting for org files:
- Heading, then immediately PROPERTIES (if any)
- Then immediately SCHEDULED/DEADLINE (if any)
- Then ONE blank line before body content (if any)
- ONE blank line before next heading at same/higher level
#+begin_src emacs-lisp
(after! org
  ;; Set up org-capture templates for inbox
  (setq org-capture-templates
        '(("i" "Inbox TODO" entry
           (file+olp "~/Documents/brain2/inbox.org" "Global")
           "** TODO %?\n"
           :empty-lines 1)
          ("w" "Weekly TODO" entry
           (file+olp "~/Documents/brain2/inbox.org" "This Week")
           "** TODO %?\n"
           :empty-lines 1)))
  
  (defun my/org-format-buffer ()
    "Format org buffer with consistent, clean spacing matching example.org style."
    (interactive)
    (save-excursion
      ;; First, remove ALL blank lines in entire buffer
      (goto-char (point-min))
      (while (re-search-forward "\n\n+" nil t)
        (replace-match "\n"))
      
      ;; Add blank line after title/filetags section
      (goto-char (point-min))
      (when (re-search-forward "^#\\+\\(TITLE\\|FILETAGS\\):" nil t)
        (forward-line 1)
        (while (looking-at "^#\\+")
          (forward-line 1))
        (when (looking-at "^:PROPERTIES:")
          (re-search-forward "^:END:" nil t)
          (forward-line 1))
        (when (looking-at "^\\*")
          (insert "\n")))
      
      ;; Process all headings
      (goto-char (point-min))
      (while (re-search-forward "^\\(\\*+\\) " nil t)
        (forward-line 1)
        (when (looking-at "^[ \t]*:PROPERTIES:")
          (re-search-forward "^[ \t]*:END:" nil t)
          (forward-line 1))
        (while (looking-at "^[ \t]*\\(SCHEDULED:\\|DEADLINE:\\|CLOSED:\\)")
          (forward-line 1))
        (when (looking-at "^[ \t]*:LOGBOOK:")
          (re-search-forward "^[ \t]*:END:" nil t)
          (forward-line 1))
        (let ((content-start (point)))
          (cond
           ((eobp)
            (insert "\n"))
           ((looking-at "^\\*")
            (insert "\n"))
           (t
            (goto-char content-start)
            (insert "\n")
            (if (re-search-forward "^\\*" nil t)
                (progn
                  (beginning-of-line)
                  (insert "\n")
                  (beginning-of-line))
              (goto-char (point-max))
              (unless (bolp)
                (insert "\n")))))))
      
      ;; Add blank lines before attachment links (but not after captions)
      (goto-char (point-min))
      (while (re-search-forward "^\\[\\[attachment:" nil t)
        (beginning-of-line)
        ;; Check if previous line is not blank and not an italic caption
        (unless (or (bobp)
                    (save-excursion
                      (forward-line -1)
                      (or (looking-at "^[ \t]*$")
                          (looking-at "^/"))))
          (insert "\n"))
        (forward-line 1))
      
      ;; Add blank lines after italic captions (when followed by attachment or body text)
      (goto-char (point-min))
      (while (re-search-forward "^/.+/$" nil t)
        (forward-line 1)
        ;; Add blank line if next line exists and is not blank and not a heading
        (unless (or (eobp)
                    (looking-at "^[ \t]*$")
                    (looking-at "^\\*"))
          (insert "\n")))
      
      ;; Clean up trailing blank lines
      (goto-char (point-max))
      (while (and (> (point) 1)
                  (eq (char-before) ?\n)
                  (eq (char-before (1- (point))) ?\n))
        (delete-char -1))))
   
   ;; Enable auto-format on save
    (add-hook 'org-mode-hook
      (lambda ()
        (add-hook 'before-save-hook #'my/org-format-buffer nil t)))
   )
#+end_src

* Org Inline Images

Optimize inline image display performance by limiting the display width.
This dramatically reduces lag when scrolling past large screenshots (e.g., 1920x1080).
Images are displayed at max 800px width while the full-resolution files remain unchanged.
To view the full resolution, open the image externally with =RET= on the link.
#+begin_src emacs-lisp
(after! org
  ;; Display images at max 800px width instead of full resolution
  ;; This reduces rendering overhead for large screenshots
  (setq org-image-actual-width 600)
  ;; Left-align by default (centered in writeroom mode via hook below)
  (setq org-image-align 'left))
#+end_src

** Unified Image Display for Org-Download

Override org-download to display ALL images in buffer after pasting.
This ensures consistent toggle behavior (=z i=) for both pasted and manually attached images.
Without this, pasting a new image only displays images in the current heading,
which breaks toggle functionality for manual attachments in other headings.
#+begin_src emacs-lisp
;; Override org-download to display ALL images after pasting
;; This ensures consistent toggle behavior with z i for both pasted and manual attachments
(after! org-download
  (defun org-download--display-inline-images ()
    "Display all inline images in buffer after pasting.
This ensures org-inline-image-overlays includes all images,
making z i toggle work consistently for manual and pasted attachments."
    (when (eq org-download-display-inline-images t)
      (org-display-inline-images t nil (point-min) (point-max)))))
#+end_src

* Zen Mode Customization

Configure zen mode (writeroom-mode) with variable-pitch font for comfortable prose writing.
#+begin_src emacs-lisp
(setq +zen-text-scale 1)           ;; Font size scale (1 = one size larger for readability)
(setq writeroom-width 65)          ;; Column width (45 text columns = ~55 char margins on each side)
;; Configure org-modern to always be on for org-mode
(after! org-modern
  (setq org-modern-fold-stars '(("∵" . "∴"))
        org-modern-hide-stars 'leading)
  ;; Enable org-modern globally
  (add-hook 'org-mode-hook #'org-modern-mode))
;; Zen mode hook - enable variable-pitch, hide line numbers, center images
(add-hook 'writeroom-mode-hook
  (lambda ()
    (if writeroom-mode
        (progn
          (display-line-numbers-mode -1)
          (when (derived-mode-p 'org-mode)
            (setq-local org-modern-hide-stars t)
            (variable-pitch-mode 1)  ; Use proportional font for prose
            (setq-local org-image-align 'center)  ; Center images in zen mode
            (when org-inline-image-overlays  ; Refresh if images are displayed
              (org-redisplay-inline-images)))
          (text-scale-set 2))  ; Larger font for comfortable reading
      (progn
        ;; Restore when exiting zen mode
        (display-line-numbers-mode 1)
        (when (derived-mode-p 'org-mode)
          (setq-local org-modern-hide-stars 'leading)
          (variable-pitch-mode -1)
          (setq-local org-image-align 'left)  ; Restore left alignment
          (when org-inline-image-overlays  ; Refresh if images are displayed
            (org-redisplay-inline-images)))))))
#+end_src

* Dashboard Customization

#+begin_src emacs-lisp
;; Use custom Emacs logo as dashboard banner (300x300 Lanczos-smoothed)
(setq +doom-dashboard-banner-file "emacs-logo-300-smooth.xpm")
;; Dashboard menu sections
(setq +doom-dashboard-menu-sections
      '(("Open project"
         :icon (nerd-icons-devicon "nf-dev-git" :face 'doom-dashboard-menu-title :height 1.3)
         :action projectile-switch-project)
        ("Open documentation"
         :icon (nerd-icons-faicon "nf-fa-book_atlas" :face 'doom-dashboard-menu-title :height 1.3)
         :action doom/help)))
(after! doom-dashboard
  ;; Adjust banner padding for better vertical centering
  (setq +doom-dashboard-banner-padding '(8 . 4))
  ;; Override the banner widget to properly center the image
  (defun doom-dashboard-widget-banner ()
    (let ((point (point)))
      (if (and (display-graphic-p)
               (stringp fancy-splash-image)
               (file-readable-p fancy-splash-image))
          (let* ((image (create-image (fancy-splash-image-file)))
                 (img-width (car (image-size image t)))
                 ;; Add 2 extra spaces to shift right slightly
                 (line (make-string (max 1 (+ img-width 2)) ? )))
            ;; Insert a centered spacer line and display the image on it
            (insert (+doom-dashboard--center +doom-dashboard--width line) "\n")
            (add-text-properties
             point (1- (point)) `(display ,image rear-nonsticky (display)))
            (insert (make-string (or (cdr +doom-dashboard-banner-padding) 0)
                                 ?\n)))
        ;; Fallback to ASCII banner in terminal mode (optional)
        nil)))
  ;; Custom shortmenu with tighter spacing - use single newline instead of double
  (defun my/doom-dashboard-widget-shortmenu ()
    (insert "\n")
    (dolist (section +doom-dashboard-menu-sections)
      (cl-destructuring-bind (label &key icon action when face key) section
        (when (and (fboundp action)
                   (or (null when)
                       (eval when t)))
          (insert
           (+doom-dashboard--center
            (- +doom-dashboard--width 1)
            (let ((icon (if (stringp icon) icon (eval icon t))))
              (format (format "%s%%s%%-10s" (if icon "%3s\t" "%3s"))
                      (or icon "")
                      (with-temp-buffer
                        (insert-text-button
                         label
                         'action
                         `(lambda (_)
                            (call-interactively (or (command-remapping #',action)
                                                    #',action)))
                         'face (or face 'doom-dashboard-menu-title)
                         'follow-link t
                         'help-echo
                         (format "%s (%s)" label
                                 (propertize (symbol-name action) 'face 'doom-dashboard-menu-desc)))
                        (format "%-37s" (buffer-string)))
                      ;; Lookup command keys dynamically
                      (propertize
                       (or key
                           (when-let*
                               ((keymaps
                                 (delq
                                  nil (list (when (bound-and-true-p evil-local-mode)
                                              (evil-get-auxiliary-keymap +doom-dashboard-mode-map 'normal))
                                            +doom-dashboard-mode-map)))
                                (key
                                 (or (when keymaps
                                       (where-is-internal action keymaps t))
                                     (where-is-internal action nil t))))
                             (with-temp-buffer
                               (save-excursion (insert (key-description key)))
                               (while (re-search-forward "<\\([^>]+\\)>" nil t)
                                 (let ((str (match-string 1)))
                                   (replace-match
                                    (upcase (if (< (length str) 3)
                                                str
                                              (substring str 0 3))))))
                               (buffer-string)))
                           "")
                       'face 'doom-dashboard-menu-desc))))
           "\n")))))  ;; Use single \n instead of \n\n
  ;; Override dashboard widgets - remove loaded time, keep banner and menu
  (setq +doom-dashboard-functions
        '(doom-dashboard-widget-banner
          my/doom-dashboard-widget-shortmenu
          doom-dashboard-widget-footer))
  ;; Force reload dashboard to apply changes
  (when (get-buffer +doom-dashboard-name)
    (+doom-dashboard-reload t)))
#+end_src

* PDF Configuration

Configure pdf-tools for viewing PDF files in Emacs.
#+begin_src emacs-lisp
(use-package! pdf-tools
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :config
  (pdf-tools-install)
  (setq pdf-view-continuous t))
#+end_src

* Vterm Configuration

Evil intercepts ESC globally before vterm can handle it.
Disable Evil's ESC keybinding in vterm buffers.
#+begin_src emacs-lisp
(after! vterm
  (add-hook 'vterm-mode-hook
    (lambda ()
      ;; ESC sends to terminal, not evil
      (evil-define-key 'insert vterm-mode-map
        (kbd "<escape>") 'vterm-send-escape)
      ;; Ctrl-c Ctrl-c enters normal mode
      (evil-define-key 'insert vterm-mode-map
        (kbd "C-c C-c") 'evil-normal-state))))
#+end_src

* Circe IRC Configuration

Configure Circe for automatic authentication with Libera Chat using SASL.
#+begin_src emacs-lisp
(setq circe-network-options
      '(("Libera Chat"
         :tls t
         :nick "Crocod1le"
         :sasl-username "Crocod1le"
         :sasl-password "Eight0011!!")))
#+end_src
To connect to Libera Chat with automatic authentication, simply run:
- =M-x circe RET Libera Chat RET=
This will connect you to Libera Chat and automatically authenticate your account.
<!-- Local Variables: -->
<!-- gptel-model: gpt-5-mini -->
<!-- gptel--backend-name: "Copilot" -->
<!-- gptel--bounds: nil -->
<!-- End: -->
