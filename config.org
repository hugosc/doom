#+TITLE: Doom Emacs Configuration
#+AUTHOR: Croc
#+PROPERTY: header-args :tangle yes :cache yes :results silent :padline no

* Table of Contents :TOC:

- [[#introduction][Introduction]]
- [[#basic-settings][Basic Settings]]
  - [[#directories][Directories]]
  - [[#auto-revert-mode][Auto-revert Mode]]
  - [[#user-information][User Information]]
  - [[#line-numbers][Line Numbers]]
- [[#visual-configuration][Visual Configuration]]
  - [[#fonts][Fonts]]
  - [[#theme-pywal-integration][Theme: Pywal Integration]]
- [[#org-roam-configuration][Org-Roam Configuration]]
  - [[#org-roam-ui][Org-Roam UI]]
  - [[#capture-templates][Capture Templates]]
  - [[#helper-functions][Helper Functions]]
  - [[#keybindings][Keybindings]]
- [[#lecture-processing][Lecture Processing]]
- [[#file-navigation][File Navigation]]
- [[#ai-integration-gptel][AI Integration: GPTel]]
- [[#org-agenda][Org Agenda]]
- [[#org-formatting][Org Formatting]]

* Introduction

This is my Doom Emacs configuration, written in a literate style using org-mode.
The configuration is focused on academic work with org-roam for knowledge management
and GPTel for AI assistance via GitHub Copilot.

* Basic Settings

** Directories

Set the org-roam directory to my brain2 vault. This must be set before org-roam loads.

#+begin_src emacs-lisp
(setq org-roam-directory "~/Documents/brain2")
#+end_src

Set the general org-directory for agenda and other org features.

#+begin_src emacs-lisp
(setq org-directory "~/Documents/brain2/")
#+end_src

** Emacs Server

Start the emacs server to allow emacsclient connections (required for daemon mode and pywal hooks).

#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))

;; Also ensure server starts if running in daemon mode
(when (daemonp)
  (add-hook 'after-make-frame-functions
    (lambda (frame)
      (when (not (server-running-p))
        (server-start)))))
#+end_src

** Auto-revert Mode

Enable global auto-revert mode to automatically reload files when they change externally.
This is especially useful when working with external tools like OpenCode.

#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(setq auto-revert-verbose t)
#+end_src

** User Information

Configure user information for GPG, email clients, and file templates.

#+begin_src emacs-lisp
;; (setq user-full-name "John Doe"
;;       user-mail-address "john@doe.com")
#+end_src

** Line Numbers

Display line numbers in programming and text modes.

#+begin_src emacs-lisp
(setq display-line-numbers-type t)
#+end_src

* Visual Configuration

** Fonts

Doom exposes five font variables for customization:
- =doom-font= -- the primary font to use
- =doom-variable-pitch-font= -- a non-monospace font (where applicable)
- =doom-big-font= -- used for =doom-big-font-mode=
- =doom-symbol-font= -- for symbols
- =doom-serif-font= -- for the =fixed-pitch-serif= face

Example configuration (commented out):

#+begin_src emacs-lisp
;; (setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'semi-light)
;;       doom-variable-pitch-font (font-spec :family "Fira Sans" :size 13))
#+end_src

** Theme: Pywal Integration

I use =ewal= to integrate pywal colors with Doom themes, allowing my Emacs theme
to automatically match my wallpaper color scheme.

#+begin_src emacs-lisp
(use-package! ewal
  :init (setq ewal-use-built-in-always-p nil
              ewal-use-built-in-on-failure-p t
              ewal-built-in-palette "doom-one"))

(use-package! ewal-doom-themes
  :after ewal
  :config (progn
            (load-theme 'ewal-doom-one t)
            (enable-theme 'ewal-doom-one)))
#+end_src

Helper function to reload the pywal theme after changing wallpaper:

#+begin_src emacs-lisp
(defun reload-pywal-theme ()
  "Reload the pywal theme to reflect new colors."
  (interactive)
  (ewal-load-colors)
  (load-theme 'ewal-doom-one t)
  (message "Pywal theme reloaded!"))
#+end_src

** Transparency Toggle and Pywal Auto-Reload

Toggle emacs transparency to match kitty when Super+Shift+P is pressed.
This makes emacs background respond dynamically to kitty opacity changes.

Also set up file watcher to auto-reload theme when pywal colors change.

#+begin_src emacs-lisp
;; Toggle emacs frame alpha (transparency) to match kitty
(defun toggle-emacs-transparency ()
  "Toggle emacs frame transparency between opaque (100%) and semi-transparent (85%)."
  (interactive)
  (let* ((alpha-param (frame-parameter nil 'alpha-background))
         (current-alpha (or alpha-param 100))
         (new-alpha (if (>= current-alpha 95) 85 100)))
    (set-frame-parameter nil 'alpha-background new-alpha)
    (message "Emacs transparency: %d%%" new-alpha)))

;; Watch for changes to pywal colors and reload theme automatically
(defun my/watch-pywal-colors ()
  "Set up file watcher for pywal colors.json to auto-reload theme."
  (when (functionp 'file-notify-add-watch)
    (let ((colors-file (expand-file-name "~/.cache/wal/colorscheme.json")))
      (when (file-exists-p colors-file)
        (file-notify-add-watch colors-file '(change)
          (lambda (event)
            (when (eq (nth 1 event) 'changed)
              (reload-pywal-theme))))))))

;; Auto-enable the color watcher when emacs starts
(my/watch-pywal-colors)

;; Set initial transparency to match kitty (85%)
(set-frame-parameter nil 'alpha-background 85)
#+end_src

* Org-Roam Configuration

My org-roam setup is designed for academic work, using a Zettelkasten-style
knowledge management system with concepts, lectures, readings, and projects.

** Org-Roam UI

Configure org-roam-ui for visual graph navigation of my knowledge base.

#+begin_src emacs-lisp
(use-package! org-roam-ui
  :after org-roam
  :hook (org-roam-mode . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src

** Capture Templates

My capture templates support different types of content in my knowledge system:
- *Lectures* (=l=): Raw notes from lectures with post-processing checklist
- *Concepts* (=c=): Atomic concept nodes with definition, context, relations
- *Readings* (=r=): Paper/book notes with citations
- *Assignments* (=a=): Coursework planning and tracking
- *Projects* (=p=): Personal project overviews
- *Inbox* (=i=): Quick idea capture for later processing
- *Journal* (=j=): Reflective daily/weekly notes

#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-v2-ack t)
  (setq org-roam-capture-templates
        '(("l" "Lecture quicknote" plain
           "%?\n* Post-Lecture Checklist\n- [ ] Extract definitions\n- [ ] Create/update concept node\n- [ ] Link readings\n- [ ] Mark processed"
           :if-new (file+head "academic/lectures/raw/%<%Y-%m-%d>-${slug}.org"
                              "#+TITLE: %<%Y-%m-%d> ${title} Lecture\n#+FILETAGS: :lecture:raw:\n")
           :unnarrowed t)
          ("c" "Concept node" plain
           "* Overview\n%?\n* Context\n* Relations\n* Applications\n* References"
           :if-new (file+head "concepts/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :concept:seed:\n")
           :unnarrowed t)
          ("r" "Reading note" plain
           "* Summary\n%?\n* Key Claims\n* Methods\n* Critical Reflections\n* Links"
           :if-new (file+head "readings/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :reading:seed:\n:PROPERTIES:\n:ROAM_REFS: ${ref}\n:END:\n")
           :unnarrowed t)
          ("a" "Assignment plan" plain
           "* Brief\n%?\n* Requirements\n* Sources\n* Outline\n* Timeline\n* Status"
           :if-new (file+head "assignments/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :assignment:active:\n")
           :unnarrowed t)
          ("p" "Project node" plain
           "* Overview\n%?\n* Goals\n* Links\n* Decisions\n* TODO\n* Resources"
           :if-new (file+head "projects/${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: :project:active:\n")
           :unnarrowed t)
          ("i" "Inbox idea" plain
           "Context:\n%?\nNext Action:"
           :if-new (file+head "inbox.org" "#+TITLE: Inbox\n#+FILETAGS: :inbox:\n")
           :empty-lines-before 1
           :unnarrowed t)
          ("j" "Journal entry" plain
           "%?"
           :if-new (file+head "journal/%<%Y>.org" "#+TITLE: Journal %<%Y>\n#+FILETAGS: :journal:\n")
           :empty-lines-before 1
           :unnarrowed t)))
#+end_src

** Helper Functions

*** Promote Heading to Concept

This function extracts a heading from a lecture or inbox note and promotes it
to a standalone concept node. The heading's contents are copied into the new
concept file under the =* Overview= section, and a reference link to the original
heading is added to the concept's =* References= section. The original heading
is preserved (not deleted).

#+begin_src emacs-lisp
  (defun my/org-roam-promote-heading-to-concept ()
    "Promote current heading into a new concept node.

This:
- Creates `concepts/<slug>.org` (if missing) with a scaffold that uses '* Overview'.
- Copies the current heading's subtree (content below the heading line) into
  the new file under '* Overview' (appends).
- Transfers the original heading's ID to the new file (if it exists), so existing
  links to that heading automatically resolve to the new concept file.
- Removes the ID from the original heading to avoid duplicates.
- Inserts a link to the new concept in the original file's '* Relations' section as a bullet point.

It does NOT delete or replace the original heading." 
    (interactive)
    (unless (org-at-heading-p)
      (user-error "Not at a heading"))

    (let* ((title (nth 4 (org-heading-components)))
           (node (org-roam-node-create :title title))
           (slug (org-roam-node-slug node))
           (file (expand-file-name (format "concepts/%s.org" slug) org-roam-directory))
           ;; original subtree bounds
           (orig-beg (save-excursion (org-back-to-heading t) (point)))
           (orig-end (save-excursion (org-end-of-subtree t t)))
           ;; body = text after the heading line up to end of subtree
           (body (save-restriction
                   (widen)
                   (when (> orig-end orig-beg)
                     (save-excursion
                       (goto-char orig-beg)
                       (forward-line 1)
                       ;; Skip properties drawer if present
                       (when (looking-at "^[ \t]*:PROPERTIES:")
                         (when (re-search-forward "^[ \t]*:END:" orig-end t)
                           (forward-line 1)))
                       ;; Skip any blank lines after properties
                       (while (and (< (point) orig-end) (looking-at-p "^\\s-*$"))
                         (forward-line 1))
                       ;; Extract the actual content
                       (let ((content-start (point)))
                         (when (< content-start orig-end)
                           (string-trim (buffer-substring-no-properties content-start orig-end)))))))))
      ;; Ensure original heading has an ID so we can link to it later if needed
      (let ((orig-id (save-excursion
                       (org-back-to-heading t)
                       (or (org-entry-get nil "ID")
                           (org-id-get-create)))))
        ;; Create scaffold if file doesn't exist
        (unless (file-exists-p file)
          (with-temp-file file
            (insert ":PROPERTIES:\n:END:\n#+TITLE: " title "\n#+FILETAGS: :concept:seed:\n\n* Overview\n\n* Context\n* Relations\n* Applications\n* References\n")))
        ;; Transfer or create ID: use heading's existing ID if present, otherwise generate new one
        (let ((new-id (if orig-id
                          ;; Use the original heading's ID for the new file
                          (progn
                            (with-current-buffer (find-file-noselect file)
                              (goto-char (point-min))
                              (when (re-search-forward "^:PROPERTIES:" nil t)
                                (forward-line 1)
                                (insert (format ":ID: %s\n" orig-id)))
                              (save-buffer))
                            ;; Delete entire properties drawer from original heading
                            (save-excursion
                              (org-back-to-heading t)
                              (when (re-search-forward "^[ \t]*:PROPERTIES:" (save-excursion (outline-next-heading) (point)) t)
                                (let ((beg (line-beginning-position)))
                                  (when (re-search-forward "^[ \t]*:END:" (save-excursion (outline-next-heading) (point)) t)
                                    (delete-region beg (1+ (line-end-position)))))))
                            (save-buffer)
                            orig-id)
                        ;; No existing ID, generate a new one for the concept file
                        (let ((generated-id (org-id-new)))
                          (with-current-buffer (find-file-noselect file)
                            (goto-char (point-min))
                            (when (re-search-forward "^:PROPERTIES:" nil t)
                              (forward-line 1)
                              (insert (format ":ID: %s\n" generated-id)))
                            (save-buffer))
                          generated-id))))
          ;; Insert body into Overview if present
          (when (and body (not (string-empty-p (string-trim body))))
            (with-current-buffer (find-file-noselect file)
              (save-excursion
                (goto-char (point-min))
                (when (re-search-forward "^\\* Overview\\s-*$" nil t)
                  (forward-line 1)
                  ;; Clean up: remove any existing blank lines after Overview heading
                  (while (looking-at-p "^\\s-*$")
                    (delete-region (line-beginning-position) (1+ (line-end-position))))
                  ;; Insert the trimmed body content
                  (insert (string-trim body) "\n")
                  (save-buffer)))))

          ;; Insert a link to the NEW concept into the original file's *Relations section
          (save-excursion
            (goto-char (point-min))
            (if (re-search-forward "^\\* Relations\\s-*$" nil t)
                ;; Found Relations section, insert link
                (progn
                  (forward-line 1)
                  (insert (format "- [[id:%s][%s]]\n" new-id title))
                  (save-buffer))
              ;; No Relations section, create one at end of file
              (goto-char (point-max))
              (unless (bolp) (insert "\n"))
              (insert (format "* Relations\n- [[id:%s][%s]]\n" new-id title))
              (save-buffer)))
          (message "Promoted '%s' â†’ %s (id:%s) and inserted link in original file" title file new-id)))))
#+end_src

*** Insert File Link

Insert a link to an external file (useful for linking to project files, GitHub repos, etc).

#+begin_src emacs-lisp
  (defun my/insert-file-link (path)
    "Insert an org file link to PATH with basename as description."
    (interactive "fFile: ")
    (insert (format "[[file:%s][%s]]" (abbreviate-file-name path) (file-name-base path))))
#+end_src

*** Add Heading ID

Add a UUID to a heading with a human-readable alias for easier referencing.

#+begin_src emacs-lisp
  (defun my/add-heading-id ()
    "Add org-id UUID to heading with filename-heading alias for org-roam."
    (interactive)
    (org-back-to-heading t)
    (let* ((filename (file-name-base (buffer-file-name)))
           (title (nth 4 (org-heading-components)))
           (alias (format "%s - %s" filename title))
           (id (org-id-get-create)))
      (org-set-property "ROAM_ALIASES" (format "\"%s\"" alias))
      (message "Added ID with alias: %s" alias)))
#+end_src

*** Insert Heading Link

Interactive function to pick an org file and heading, then insert a link with proper ID.

#+begin_src emacs-lisp
  (defun my/insert-heading-link ()
    "Pick an org file recursively, then link to a heading with org-id."
    (interactive)
    (let* ((current-buf (current-buffer))
           (brain2-dir (expand-file-name "~/Documents/brain2/"))
           (default-directory brain2-dir)
           ;; Get all org files recursively
           (org-files (directory-files-recursively brain2-dir "\\.org$"))
           ;; Make paths relative for cleaner display
           (file-choices (mapcar (lambda (f) (file-relative-name f brain2-dir)) org-files))
           (file-rel (completing-read "Org file: " file-choices nil t))
           (file (expand-file-name file-rel brain2-dir))
           (filename (file-name-base file)))
      (unless (file-exists-p file)
        (user-error "File not found: %s" file))
      ;; List headings in that file
      (with-current-buffer (find-file-noselect file)
        (let* ((headings (org-map-entries (lambda () (nth 4 (org-heading-components))) nil 'file))
               (heading (completing-read "Heading: " headings)))
          ;; Find the heading and get/create its ID
          (goto-char (point-min))
          (unless (search-forward heading nil t)
            (user-error "Heading not found: %s" heading))
          (org-back-to-heading t)
          (let* ((id (org-id-get-create))
                 (alias (format "%s - %s" filename heading))
                 (link (format "[[id:%s][%s]]" id heading)))
            ;; Ensure alias is set
            (unless (org-entry-get nil "ROAM_ALIASES")
              (org-set-property "ROAM_ALIASES" (format "\"%s\"" alias)))
            ;; Switch back to original buffer and insert link
            (with-current-buffer current-buf
              (insert link)
              (message "Inserted link: %s" link)))))))
#+end_src

** Keybindings

All org-roam related keybindings are under the =SPC n= prefix.

#+begin_src emacs-lisp
  (map! :leader
        :desc "Promote heading to concept" "n P" #'my/org-roam-promote-heading-to-concept
        :desc "Insert file link" "n f" #'my/insert-file-link
        :desc "Add heading ID" "n i" #'my/add-heading-id
        :desc "Insert heading link" "n h" #'my/insert-heading-link
        :desc "Find/create node" "n n" #'org-roam-node-find
        :desc "Insert node link" "n l" #'org-roam-node-insert
        :desc "Toggle backlinks" "n b" #'org-roam-buffer-toggle
        :desc "Open graph UI" "n g" #'org-roam-ui-open
        :desc "Capture new node" "n c" #'org-roam-capture)
#+end_src

Close the =after! org-roam= block:

#+begin_src emacs-lisp
)
#+end_src

* Lecture Processing

Helper function to mark a lecture as processed and move it from =raw/= to =processed/=.

#+begin_src emacs-lisp
(defun my/mark-lecture-processed ()
  "Mark current lecture note as processed and move to processed directory."
  (interactive)
  (let* ((file (buffer-file-name))
         (rel (file-relative-name file org-roam-directory)))
    (unless (string-match-p "academic/lectures/raw/" rel)
      (user-error "Not in raw lectures directory"))
    (save-excursion
      (goto-char (point-min))
      (unless (re-search-forward "POST-LECTURE CHECKLIST" nil t)
        (goto-char (point-max)))
      (save-buffer)
      (org-set-property "PROCESSED" (format-time-string "%Y-%m-%d")))
    (let* ((dest (expand-file-name (concat "academic/lectures/processed/" (file-name-nondirectory file)) org-roam-directory)))
      (rename-file file dest 1)
      (find-file dest)
      (message "Lecture processed & moved."))))

(map! :leader :desc "Process lecture" "n L" #'my/mark-lecture-processed)
#+end_src

* File Navigation

Use =consult-fd= for live, telescope-like file finding without caching.

#+begin_src emacs-lisp
(map! :leader :desc "Find file (live)" "SPC" #'consult-fd)
#+end_src

* AI Integration: GPTel

GPTel provides AI assistance directly in Emacs. 

#+begin_src emacs-lisp
(use-package! gptel
  :config
  (setq gptel-model 'gpt-5-mini
        gptel-backend (gptel-make-gh-copilot "Copilot")))
#+end_src

To use GPTel:
- =M-x gptel= -- Open a chat buffer
- =M-x gptel-menu= -- Select model/backend
- In org-mode, select region and send to gptel for processing

* Discord Presence

Show your Emacs activity on Discord using emacs-rpc.

#+begin_src emacs-lisp
(use-package! presence
  :defer t
  :commands (presence-mode)
  :init
  (add-hook 'doom-first-buffer-hook #'presence-mode)
  :config
  ;; Use custom Discord application
  (setq presence-client-id "1443438985878962228")
  ;; Use asset keys directly (not URLs) for our custom Discord app
  (setq presence-icon-base nil)
  ;; Override to return just the asset key
  (defun presence--resolve-icon-base (icon)
    "Return just the icon asset key for Discord."
    icon)
  ;; Use custom icon from our Discord app
  (setq presence-editor-icon "emacs-icon")
  ;; Keep editor as main icon, mode as small icon
  (setq presence-use-major-mode-as-main-icon nil)
  ;; Show the small icon (mode icon)
  (setq presence-show-small-icon t)
  ;; Hide line numbers from status
  (setq presence-display-line-numbers nil)
  ;; Custom format: show project name + file instead of just buffer name
  (defun my/presence-buffer-details ()
    (let ((project (projectile-project-name))
          (file (buffer-name)))
      (if (and project (not (string= project "-")))
          (format "In %s: %s" project file)
        (format "Editing %s" file))))
  (setq presence-buffer-details-format-function #'my/presence-buffer-details))
#+end_src

* Org Agenda

Configure org-agenda to search the entire brain2 directory for TODOs and scheduled items.

#+begin_src emacs-lisp
(after! org
  (setq org-agenda-files '("~/Documents/brain2/")
        org-hide-emphasis-markers t)
  ;; Fallback: ensure emphasis markers are hidden when org-mode starts
  (add-hook 'org-mode-hook (lambda () (setq org-hide-emphasis-markers t))))
#+end_src

* Org Formatting

Automatically format org files with consistent spacing:
- No blank line between heading and properties drawer
- Blank line after properties drawer before content
- Blank line after headings before content

#+begin_src emacs-lisp
(after! org
  (defun my/org-format-buffer ()
    "Format org buffer with consistent spacing."
    (interactive)
    (message "Running org-format-buffer...")
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\*+ " nil t)
        (let ((heading-pos (line-beginning-position)))
          ;; Check if next line is properties drawer
          (forward-line 1)
          (when (looking-at "^[ \t]*:PROPERTIES:")
            ;; Remove any blank lines between heading and properties
            (goto-char heading-pos)
            (forward-line 1)
            (while (and (not (looking-at "^[ \t]*:PROPERTIES:"))
                       (looking-at-p "^\\s-*$"))
              (delete-region (line-beginning-position) (1+ (line-end-position))))
            ;; Find end of properties
            (when (re-search-forward "^[ \t]*:END:" nil t)
              (forward-line 1)
              ;; Ensure exactly one blank line after properties
              (let ((content-start (point)))
                (while (looking-at-p "^\\s-*$")
                  (forward-line 1))
                (unless (= (point) (1+ content-start))
                  (delete-region content-start (point))
                  (goto-char content-start)
                  (unless (or (looking-at "^\\*") (eobp))
                    (insert "\n"))))))
          ;; If no properties, ensure blank line after heading
          (goto-char heading-pos)
          (forward-line 1)
          (unless (or (looking-at "^[ \t]*:PROPERTIES:")
                     (looking-at-p "^\\s-*$")
                     (looking-at "^\\*")
                     (eobp))
            (insert "\n")))))
    
    ;; Ensure blank line before each heading (after content)
    (save-excursion
      (goto-char (point-min))
      ;; Skip first heading
      (when (re-search-forward "^\\*+ " nil t)
        (beginning-of-line)
        (while (re-search-forward "^\\*+ " nil t)
          (beginning-of-line)
          (let ((heading-pos (point)))
            (forward-line -1)
            ;; If previous line is not blank and not a heading, add blank line
            (when (and (not (looking-at-p "^\\s-*$"))
                       (not (looking-at "^\\*")))
              (end-of-line)
              (insert "\n"))
            ;; Move past this heading to continue loop
            (goto-char heading-pos)
            (forward-line 1))))))
  
   ;; Run formatting on save
   (add-hook 'org-mode-hook
     (lambda ()
       (add-hook 'before-save-hook #'my/org-format-buffer nil t))))
#+end_src

* Zen Mode Customization

Configure zen mode (writeroom-mode) with smaller font, wider margins, no line numbers, and hidden org stars.

#+begin_src emacs-lisp
(setq +zen-text-scale 1)           ;; Font size scale (1 = one size larger)
(setq writeroom-width 70)          ;; Column width (narrower = wider margins)

;; Configure org-modern to always be on for org-mode
(after! org-modern
  (setq org-modern-hide-stars 'leading)
  ;; Enable org-modern globally
  (add-hook 'org-mode-hook #'org-modern-mode))

;; Zen mode hook - hide line numbers, adjust org-modern star display
(add-hook 'writeroom-mode-hook
  (lambda ()
    (if writeroom-mode
        (progn
          (display-line-numbers-mode -1)
          (when (derived-mode-p 'org-mode)
            (setq-local org-modern-hide-stars t))
          (text-scale-set 1))
      (progn
        ;; Restore when exiting zen mode
        (display-line-numbers-mode 1)
        (when (derived-mode-p 'org-mode)
          (setq-local org-modern-hide-stars 'leading))))))
#+end_src

* Dashboard Customization

#+begin_src emacs-lisp
;; Use custom octopus ASCII art as the dashboard banner with minimal menu.
#+end_src

#+begin_src emacs-lisp
(defun my/doom-dashboard-octopus ()
  "Insert octopus ASCII art for dashboard."
  (let ((octopus-file (expand-file-name "~/.config/doom/banners/octopus.txt")))
    (when (file-readable-p octopus-file)
      (insert
       (with-temp-buffer
         (insert-file-contents octopus-file)
         (buffer-string))))))

(setq +doom-dashboard-ascii-banner-fn #'my/doom-dashboard-octopus)

;; Minimal menu - just open project and open docs
(setq +doom-dashboard-menu-sections
      '(("Open project"
         :icon (nerd-icons-octicon "nf-oct-briefcase" :face 'doom-dashboard-menu-title)
         :action projectile-switch-project)
        ("Open documentation"
         :icon (nerd-icons-octicon "nf-oct-book" :face 'doom-dashboard-menu-title)
         :action doom/help)))

;; Custom shortmenu with tighter spacing - use single newline instead of double
(defun my/doom-dashboard-widget-shortmenu ()
  (insert "\n")
  (dolist (section +doom-dashboard-menu-sections)
    (cl-destructuring-bind (label &key icon action when face key) section
      (when (and (fboundp action)
                 (or (null when)
                     (eval when t)))
        (insert
         (+doom-dashboard--center
          (- +doom-dashboard--width 1)
          (let ((icon (if (stringp icon) icon (eval icon t))))
            (format (format "%s%%s%%-10s" (if icon "%3s\t" "%3s"))
                    (or icon "")
                    (with-temp-buffer
                      (insert-text-button
                       label
                       'action
                       `(lambda (_)
                          (call-interactively (or (command-remapping #',action)
                                                  #',action)))
                       'face (or face 'doom-dashboard-menu-title)
                       'follow-link t
                       'help-echo
                       (format "%s (%s)" label
                               (propertize (symbol-name action) 'face 'doom-dashboard-menu-desc)))
                      (format "%-37s" (buffer-string)))
                    ;; Lookup command keys dynamically
                    (propertize
                     (or key
                         (when-let*
                             ((keymaps
                               (delq
                                nil (list (when (bound-and-true-p evil-local-mode)
                                            (evil-get-auxiliary-keymap +doom-dashboard-mode-map 'normal))
                                          +doom-dashboard-mode-map)))
                              (key
                               (or (when keymaps
                                     (where-is-internal action keymaps t))
                                   (where-is-internal action nil t))))
                           (with-temp-buffer
                             (save-excursion (insert (key-description key)))
                             (while (re-search-forward "<\\([^>]+\\)>" nil t)
                               (let ((str (match-string 1)))
                                 (replace-match
                                  (upcase (if (< (length str) 3)
                                              str
                                            (substring str 0 3))))))
                             (buffer-string)))
                         "")
                     'face 'doom-dashboard-menu-desc))))
         "\n")))))  ;; Use single \n instead of \n\n

;; Override dashboard widgets - remove loaded time, keep banner and menu
(setq +doom-dashboard-functions
      '(doom-dashboard-widget-banner
        my/doom-dashboard-widget-shortmenu
        doom-dashboard-widget-footer))
#+end_src

<!-- Local Variables: -->
<!-- gptel-model: gpt-5-mini -->
<!-- gptel--backend-name: "Copilot" -->
<!-- gptel--bounds: nil -->
<!-- End: -->
